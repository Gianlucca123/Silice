// @sylefeb 2021
// MIT license, see LICENSE_MIT in Silice repo root
// https://github.com/sylefeb/Silice
//
// ========================================================
// IMPORTANT: on the ice40, use icepack -s
// ========================================================
//
// Highly recommanded watch on timing analysis for SPIflash on ice40:
//   https://www.youtube.com/watch?v=mitAhMOt3zI&t=1400s
//
// For a (more stable/reliable) Verilog SPIflash 100MHz
// controller also see smunaut (@tnt) repos:
//   https://github.com/no2fpga/no2qpimem/blob/master/rtl/qpi_phy_ice40_4x.v

import('ddr_clock.v')

$$if VERILATOR then
import('../common/verilator_data.v') // this is a feature supported by Silice
                                     // verilator framework to access raw data
                                     // stored in a 'data.raw' file
$$end

$$local ICE40
$$if ICEBREAKER or ICEBITSY or FOMU then
$$ ICE40 = 1
import('../common/ice40_sb_io_inout.v')
import('../common/ice40_sb_io.v')
$$end

$$if not ICE40 and not SIMULATION then
$$error('The SPIflash x4 controller is currently only for the ice40 FPGA\n'
$$    ..'It should be possible to port it to other FPGAs with some efforts.')
$$end

$$if not nBytes then
$$ nBytes = 1
$$end

algorithm spiflash_qspi(
  input  uint8 send,
  input  uint1 trigger,
  input  uint1 send_else_read,
  input  uint1 qspi,
  output uint8 read,
  output uint1 clk,
  output uint1 csn,
  inout  uint1 io0,
  inout  uint1 io1,
  inout  uint1 io2,
  inout  uint1 io3,
) {
  uint1 dc(0);
  uint4 sending(0);
  uint1 osc(0);

  uint1 enable(0);
  ddr_clock ddr(clock <: clock, enable <:: enable, ddr_clock :> clk);

$$if not ICE40 then
  // NOTE: This is used for simulation ; it is somewhat convoluted
  // so as to simulated registered IO delays. Works best with Icarus and
  // vendor model, see stream.si in projects/spiflash
  uint1 d_csn(1);
  uint4 delay(4);
  always {
    // output enable on ios
    io0.oenable = send_else_read;
    io1.oenable = send_else_read & qspi;
    io2.oenable = send_else_read & qspi;
    io3.oenable = send_else_read & qspi;
    // read current
    read  = {read[0,4],delay};
    // simulates registered input
    delay = {io3.i,io2.i,io1.i,io0.i};
    // update outputs
    io0.o = sending[0,1];  io1.o = sending[1,1];
    io2.o = sending[2,1];  io3.o = sending[3,1];
    // start/keep sending?
    sending   = osc ? send[4,4] : send[0,4];
    osc       = ~osc;
    enable    = trigger;
    csn       = d_csn;
    d_csn     = ~enable;
  }
$$else
  // setup registered tristate ios
  uint4 io_oe(0); uint4 io_i(0); uint4 io_o(0);
  sb_io_inout sb_io0(clock <: clock, oe <: io_oe[0,1], in :> io_i[0,1], out <: io_o[0,1], pin <:> io0);
  sb_io_inout sb_io1(clock <: clock, oe <: io_oe[1,1], in :> io_i[1,1], out <: io_o[1,1], pin <:> io1);
  sb_io_inout sb_io2(clock <: clock, oe <: io_oe[2,1], in :> io_i[2,1], out <: io_o[2,1], pin <:> io2);
  sb_io_inout sb_io3(clock <: clock, oe <: io_oe[3,1], in :> io_i[3,1], out <: io_o[3,1], pin <:> io3);
  uint1 nenable <:: ~ enable;
  sb_io       sb_csn(clock <: clock, out <: nenable, pin :> csn);
  uint4 delay(0);
  always {
    // output enable on ios
    io_oe     = {{3{send_else_read & qspi}},send_else_read};
    // read current
    read      = {read[0,4],delay};
    delay     = io_i;
    // update outputs
    io_o      = sending;
    // start/keep sending?
    sending   = osc ? send[4,4] : send[0,4];
    osc       = ~osc;
    enable    = trigger;
  }
$$end
}

// -------------------------------------------------------------

algorithm spiflash_rom(
  input   uint1  in_ready,
  input   uint24 addr,
  output  uint$nBytes*8$ rdata,
  output  uint1  busy(1),
  // QSPI flash
  output  uint1  sf_csn(1),
  output  uint1  sf_clk,
  inout   uint1  sf_io0,
  inout   uint1  sf_io1,
  inout   uint1  sf_io2,
  inout   uint1  sf_io3,
  // double clock
  input   uint1  clkspi
) <autorun> {

  spiflash_qspi spiflash<reginputs,@clkspi>(
    clk     :> sf_clk,
    csn     :> sf_csn,
    io0    <:> sf_io0,
    io1    <:> sf_io1,
    io2    <:> sf_io2,
    io3    <:> sf_io3,
  );

  uint40 sendvec(0); //_ 38h (QPI enable)
  uint$4+3+nBytes$ trigger(0); // 4 for steps with 3 cycles wait
$$trig_post_0 = '0'
$$trig_post_1 = '0'
$$for i=1,nBytes-1 do
$$  trig_post_0 = '0' .. trig_post_0
$$  trig_post_1 = '1' .. trig_post_1
$$end
$$trig_post_0 = '' .. nBytes .. 'b' .. trig_post_0
$$trig_post_1 = '' .. nBytes .. 'b' .. trig_post_1
$$trig_post_x = '' .. (4+3+nBytes) .. 'b'
$$for i=1,4+3+nBytes do trig_post_x = trig_post_x .. 'x' end
$$print('######################## ' .. trig_post_0 .. ' ' .. trig_post_1)
  uint11 wait(0);
  uint5  five(0);
  uint3  stage(0);
  uint3  after(1);
  uint2  init(2b11);
  uint1  accept_in(0);
$$if nBytes > 1 then
  uint$nBytes$ rdata_done(0);
$$end
$$if SIMULATION then
  uint32 cycle(0);
$$if VERILATOR then
  verilator_data vdta(clock <: clock);
$$end
$$end
  always {

$$if not ICARUS then
    spiflash.qspi = ~init[1,1]; // qpi activated after first command
$$else
    // this is necessary for icarus as spiflash.qspi is otherwise 1bz
    spiflash.qspi = reset ? 0 : ~init[1,1];
$$end

    accept_in = 0;

    switch (stage)
    {
      case 0: {
$$if ICARUS then
        // this is necessary for icarus as spiflash.qspi is otherwise 1bz
        if (reset) { spiflash.trigger = 0; spiflash.send = 0; }
$$end
        stage = wait[10,1] ? after : 0; // counts up to 1024 and goes to after
        wait  = wait + 1;
      }
      case 1: { // idle, wait for something to do
        accept_in = 1;
      }
      case 2: {
        // move sendvec
        spiflash.send           = sendvec[32,8];
        sendvec                 = sendvec << 8;
        // send required number of bytes
        stage                   = five[0,1] ? 3 : 2;
        five                    = five >> 1;
      }
      case 3: {
        spiflash.send_else_read = 0;    // stop sending
        stage                   = 0;    // wait
        wait                    = 1023; //_ 3 cycles (one extra due to registered ios)
        after                   = 4;    // conitnue to reading
      }
$$if nBytes == 1 then
      case 4: {
  $$if VERILATOR then
        rdata                   = vdta.data;  // from 'data.raw'
  $$else
        rdata                   = spiflash.read;
  $$end
        busy                    = 0;
        init                    = {1b0,init[1,1]};
        stage                   = 1; // return to start stage
        accept_in               = 1;
$$if SIMULATION then
        //__display("[%d] spiflash DONE (%h)",cycle>>2,rdata);
$$end
      }
$$else
      case 4: {
  $$if VERILATOR then
        rdata                   = {vdta.data[0,8],rdata[8,$(nBytes-1)*8$]};  // from 'data.raw'
        vdta.addr               = rdata_done[0,1] ? vdta.addr : (vdta.addr + 1);
  $$else
        rdata                   = {spiflash.read, rdata[8,$(nBytes-1)*8$]};
  $$end
        busy                    = ~rdata_done[0,1];
        init                    = {1b0,init[1,1]};
        stage                   = rdata_done[0,1] ? 1 : 4;  // return to start stage when done
        accept_in               = rdata_done[0,1]; // we can immediately resume
        rdata_done              = rdata_done >> 1;
$$if SIMULATION then
        if (~busy) {
          //__display("[%d] spiflash DONE (%h)",cycle,rdata);
        }
$$end
      }
$$end
    } // stage

    // move trigger
    spiflash.trigger        = trigger[$4+3+nBytes-1$,1];
    trigger                 = trigger << 1;

    // start sending?
    if ((in_ready | init[1,1]) & accept_in) {
      five    = {init[0,1],~init[0,1],3b00}; // init 2b11=>5b10000, 2b01=>5b10000, 2b00=>4b01000
      sendvec = ( init[1,1] ? {32b00000000000100010001000000000000,8b0} : 0)
              | (init==2b01 ? {8hEB,addr,8b00100000}                    : 0)
              | (~init[0,1] ? {addr,8b00100000,8h00}                    : 0);
      trigger = ( init[1,1] ? {4b1111,3b000,$trig_post_0$}              : 0)
              | (init==2b01 ? {4b1111,3b111,$trig_post_1$}              : 0)
              | (~init[0,1] ? { 3b111,3b111,$trig_post_1$,1b0}          : 0);
/*
      switch (init) {
        case 2b11: {
          sendvec = {32b00000000000100010001000000000000,8b0};
          //                 ^^^^^^^^^^ produces 38h when not in QPI
          trigger = {4b1111,3b000,$trig_post_0$};
        }
        case 2b01: {
          sendvec = {8hEB,addr,8b00100000};
          trigger = {4b1111,3b111,$trig_post_1$};
        }
        case 2b00: {
          sendvec = {addr,8b00100000,8h00};
          trigger = { 3b111,3b111,$trig_post_1$,1b0};
        }
        default: {
          // explicit don't care to help synthesis
          sendvec = 40bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
          trigger = $trig_post_x$;
        }
      }
*/
      spiflash.send_else_read = 1; // sending
$$if nBytes > 1 then
      rdata_done = init[1,1] ? 1 : $1<<(nBytes-1)$;
$$end
$$if VERILATOR then
      vdta.addr = addr;
$$end
$$if SIMULATION then
      //__display("[%d] spiflash START (@%h)",cycle>>2,addr);
$$end
      busy                  = 1;
      stage                 = 2;
    }

$$if SIMULATION then
    cycle = cycle + 1;
$$end
  }
}

// -------------------------------------------------------------
