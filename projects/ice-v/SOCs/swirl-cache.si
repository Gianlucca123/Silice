// SL 2023-08 @sylefeb
//
// Cache for the ice-v-swirl
//
// directly mapped
//
// IMPORTANT: when wait goes high, memory interface should not change
//   their inputs!
// WARNING: Currently the two caches do not see writes into one another if
//   both are caching the same lines.
//   This is ok when using mem0 for instructions and mem1 for data as long as
//   code is not loaded/generated and then executed. Otherwiwe a software
//   cache flush is required.
// TODO: Implement a mechanism to avoid this issue.
// NOTE: when writting, the read value is undertermined (it will be either the
//       previously stored value or if a cache line was update the written one)
//
// https://github.com/sylefeb/Silice
// MIT license, see LICENSE_MIT in Silice repo root

// from the outside the cache acts as a BRAM when filled
interface bram_provider
{
  input   wenable,
  input   wdata,
  output! rdata,
  input   addr,
}

$$cache_line_width      = 8
$$cache_line_size_words = 1<<cache_line_width
$$cache_line_size_bytes = 1<<(cache_line_width+2)
$$num_cache_lines       = 1<<(14-cache_line_width)
$$num_cache_lines_w     = (14-cache_line_width)
$$cache_addr_w          = ramW-cache_line_width

$$print('<<cache configuration>> ' .. num_cache_lines
$$       .. ' cache lines of ' .. cache_line_size_words .. ' int32')

// --------------------------------------------------
// cache unit
// --------------------------------------------------
unit cache(
  // bram interfaces
  bram_provider mem0,
  bram_provider mem1,
  // wait goes high when cache cannot answer immediately
  // this happens the cycle after the missed address is set
  output! uint1 wait(1),
  // clock 2x for ram
  input uint1  clock2x,
  // ram io
  inout   uint1 ram_io0,  inout   uint1 ram_io1,
  inout   uint1 ram_io2,  inout   uint1 ram_io3,
  output  uint1 ram_clk,  output  uint1 ram_csn,
) {

  // cache memory (SPRAM)
  //
  // cache for mem0 is spram0,spram1 (2x 16 bits)
  // cache for mem1 is spram2,spram3 (2x 16 bits)
  //
  // each cache stores 16K x int32
  // thus 2^(14 - cache_line_width) lines of 2^cache_line_width int32
$$for n=0,3 do
$$if SIMULATION then
  simulation_spram spram$n$;
$$else
  ice40_spram      spram$n$(clock <: clock);
$$end
$$end

$$init_value=''
$$for b=1,cache_addr_w do
$$  init_value = '1' .. init_value
$$end
$$init_value = (cache_addr_w+1) .. 'b0' .. init_value

  // cache mapping
  bram uint$cache_addr_w+1$ cache0_lines[$num_cache_lines$] = {pad($init_value$)};
  bram uint$cache_addr_w+1$ cache1_lines[$num_cache_lines$] = {pad($init_value$)};
  //                     ^ dirty bit

  // determines whether requested addr match the corresponding cache line
$$for c=0,1 do
  uint$num_cache_lines_w$ line$c$_id    <: mem$c$.addr[$cache_line_width$,$num_cache_lines_w$];
  uint1                   cache$c$_hit <:: qaddr$c$[$cache_line_width$,$cache_addr_w$]
                                        == cache$c$_lines.rdata[0,$cache_addr_w$];
  // registers for memory interface inputs
  uint$num_cache_lines_w$ qline$c$_id(0);
  uint$ramW$              qaddr$c$(0);
  uint4                   qwen$c$(0);
$$end

$$if SIMULATION then
  uint32 cycle(0);
$$end

  // external RAM
  qpsram_ram ram<@clock2x>(
    ram_csn  :> ram_csn,    ram_clk  :> ram_clk,
    ram_io0 <:> ram_io0,    ram_io1 <:> ram_io1,
    ram_io2 <:> ram_io2,    ram_io3 <:> ram_io3,
  );
  uint8 reg_ram_rdata(0);
  uint8 reg_ram_datanext(0);

  uint1 update_lines_todo(0);
  uint1 update_lines_done(0);
  uint1 write_cycle(0);

  always_before {
/*
    __display("[%d] >> cache status in: @%x|@%x q: @%x|@%x miss: %b|%b ln: %x|%x",
                cycle,mem0.addr<<2,mem1.addr<<2,
                qaddr0<<2,qaddr1<<2,
                ~cache0_hit,~cache1_hit,
                cache0_lines.rdata, cache1_lines.rdata);
    __display("[%d] >> cache status in: todo: %b",cycle,update_lines_todo);
    __display("[%d] >> cache status in: wen1: %b wdata:%x",cycle,mem1.wenable,mem1.wdata);
*/
    // cache lookup
    cache0_lines.addr    = line0_id;
    cache1_lines.addr    = line1_id;
    cache0_lines.wenable = 0;
    cache1_lines.wenable = 0;
    // ram access
    ram.in_ready         = 0; // maintain low, pulse high to read/write
    ram.init             = 0; // maintain low, pulse high to init
    // default lookup
    mem0.rdata           = {spram1.data_out,spram0.data_out};
    mem1.rdata           = {spram3.data_out,spram2.data_out};
    spram0.addr          = {line0_id,mem0.addr[0,$cache_line_width$]};
    spram1.addr          = {line0_id,mem0.addr[0,$cache_line_width$]};
    spram2.addr          = {line1_id,mem1.addr[0,$cache_line_width$]};
    spram3.addr          = {line1_id,mem1.addr[0,$cache_line_width$]};
    spram0.wmask         = {{2{mem0.wenable[1,1]}},{2{mem0.wenable[0,1]}}};
    spram1.wmask         = {{2{mem0.wenable[3,1]}},{2{mem0.wenable[2,1]}}};
    spram0.wenable       = (|mem0.wenable) & (cache0_hit);
    spram1.wenable       = (|mem0.wenable) & (cache0_hit);
    spram0.data_in       = mem0.wdata[ 0,16];
    spram1.data_in       = mem0.wdata[16,16];
    spram2.wmask         = {{2{mem1.wenable[1,1]}},{2{mem1.wenable[0,1]}}};
    spram3.wmask         = {{2{mem1.wenable[3,1]}},{2{mem1.wenable[2,1]}}};
    spram2.wenable       = (|mem1.wenable) & (cache1_hit);
    spram3.wenable       = (|mem1.wenable) & (cache1_hit);
    spram2.data_in       = mem1.wdata[ 0,16];
    spram3.data_in       = mem1.wdata[16,16];
    // if both caches missed, raise wait
    wait                 = reset | ~cache0_hit | ~cache1_hit | write_cycle;
    //                     ^^^^^ wait during reset too         ^^^^^^^^^^^
    write_cycle          = 0; // additional cycle for writes, after an update
    //if (~cache0_hit | ~cache1_hit) {
    //  __display("[%d] >> cache miss %b|%b %x|%x",cycle,~cache0_hit,~cache1_hit,qaddr0<<2,qaddr1<<2);
    //}
  }

  algorithm <autorun> {

    // init QPSRAM     NOTE: assume already initialized for now
    // ram.init = 1;
    // while (ram.busy) {}
    // main loop

    while (1) {
      if (update_lines_todo) {
        // there is a pending cache miss
$$if SIMULATION then
        __display("[%d] => cache miss %b|%b %x|%x",cycle,~cache0_hit,~cache1_hit,qaddr0<<2,qaddr1<<2);
$$end
        // if line is dirty, store back
        //                  vvvvv start by cache0, then cache1
        uint1 line_dirty = ~cache0_hit ? cache0_lines.rdata[$cache_addr_w$,1]
                                       : cache1_lines.rdata[$cache_addr_w$,1];
        if (line_dirty) {
          // store back line as it was written to
          uint$ramW$ storeAddr =
            ~cache0_hit ? {cache0_lines.rdata,$cache_line_width$b0}
                        : {cache1_lines.rdata,$cache_line_width$b0};
          uint$cache_line_width+2+1$ n = 0;
$$if SIMULATION then
          __display("[%d] => [cache %b] writing at @%x from line %d",cycle,cache0_hit,storeAddr,~cache0_hit ? qline0_id : qline1_id);
$$end
          // write start addr
          ram.addr       = storeAddr;
          while (~n[$cache_line_width+2$,1]) {
            // maintain write status
            ram.in_ready = 1;
            ram.wenable  = 1;
            // vvvvv NOTE: on first iteration spramN.data_out is not ready yet,
            // however the QPSRAM controller does not access it immediately
            //
            // WARNING: watchout if increasing QPSRAM clock at 2x! (may be ok)
            //
            ram.wdata    = ~cache0_hit
                        ? {spram1.data_out,spram0.data_out} >> {n[0,2],3b0}
                        : {spram3.data_out,spram2.data_out} >> {n[0,2],3b0};
            // next?
            if (reg_ram_datanext) {
              //__write("%x,",ram.wdata);
              // next
              n = n + 1;
            }
            // read in cache 0
            spram0.addr    = {qline0_id,n[2,$cache_line_width$]};
            spram1.addr    = {qline0_id,n[2,$cache_line_width$]};
            // read in cache 1
            spram2.addr    = {qline1_id,n[2,$cache_line_width$]};
            spram3.addr    = {qline1_id,n[2,$cache_line_width$]};
          }
          ram.wenable  = 0; // stop writting
          //__display(" ");
        }
        // fetch new line
        uint$ramW$ fetchAddr =
          ~cache0_hit ? {qaddr0[$cache_line_width$,$cache_addr_w$],
                                $cache_line_width$b0}
                      : {qaddr1[$cache_line_width$,$cache_addr_w$],
                                $cache_line_width$b0};
        uint$cache_line_width+2+1$ n = 0;
$$if SIMULATION then
        __display("[%d] +> cache miss %b|%b %x|%x",cycle,~cache0_hit,~cache1_hit,qaddr0<<2,qaddr1<<2);
        __display("[%d] => [cache %b] fetching from @%x in line %d",cycle,cache0_hit,fetchAddr,~cache0_hit ? qline0_id : qline1_id);
$$end
        ram.in_ready = 1;
        ram.addr     = fetchAddr;
        while (~n[$cache_line_width+2$,1]) {
          ram.in_ready = 1;
          if (reg_ram_datanext) {
            uint4  wmask   = 2b11 << {n[0,1],1b0};
            uint16 wdata   = reg_ram_rdata << {n[0,1],3b0};
            //__write("%x,",ram.rdata);
            // cache 0
            spram0.addr    = {qline0_id,n[2,$cache_line_width$]};
            spram1.addr    = {qline0_id,n[2,$cache_line_width$]};
            spram0.data_in = wdata;
            spram1.data_in = wdata;
            spram0.wmask   = wmask;
            spram1.wmask   = wmask;
            spram0.wenable = ~cache0_hit & ~n[1,1];
            spram1.wenable = ~cache0_hit &  n[1,1];
            // __write("%b:%x,",spram1.wenable,wdata);
            // cache 1
            spram2.addr    = {qline1_id,n[2,$cache_line_width$]};
            spram3.addr    = {qline1_id,n[2,$cache_line_width$]};
            spram2.data_in = wdata;
            spram3.data_in = wdata;
            spram2.wmask   = wmask;
            spram3.wmask   = wmask;
            spram2.wenable = ~cache1_hit & ~n[1,1];
            spram3.wenable = ~cache1_hit &  n[1,1];
            // next
            n = n + 1;
          }
        }
        //__display(" ");
        // update cache register
        if (~cache0_hit) {
          cache0_lines.wdata   = {1b0,qaddr0[$cache_line_width$,$cache_addr_w$]};
          cache0_lines.wenable = 1;
        } else {
          cache1_lines.wdata   = {1b0,qaddr1[$cache_line_width$,$cache_addr_w$]};
          cache1_lines.wenable = 1;
        }
++:     // wait for cache lines bram to be written
        update_lines_done = 1; // done
        write_cycle = 1; // TODO: only if indeed writing ...
$$if SIMULATION then
        __display("[%d] cache done.",cycle);
$$end
      } else {
        // if no cache miss maintain dirty flag
        cache0_lines.wdata   = {(|qwen0) & cache0_hit,$cache_addr_w$b0} | cache0_lines.rdata;
        cache0_lines.wenable = (|qwen0) & cache0_hit;
        cache1_lines.wdata   = {(|qwen1) & cache1_hit,$cache_addr_w$b0} | cache1_lines.rdata;
        cache1_lines.wenable = (|qwen1) & cache1_hit;
      }
    }

  }

  always_after {
    // note that cache lines have to be updated next cycle
    update_lines_todo = ~reset & (~cache0_hit|~cache1_hit) & ~update_lines_done;
    update_lines_done = 0;
    // register inputs from memory interfaces: improves fmax and 'free'
    // as cache update always occurs a cycle after memory interfaces change
    qline0_id = line0_id;     qline1_id = line1_id;
    qaddr0    = mem0.addr;    qaddr1    = mem1.addr;
    qwen0     = mem0.wenable; qwen1     = mem1.wenable;
    // cross clock domain
    reg_ram_rdata    = ram.rdata;
    reg_ram_datanext = ram.data_next;
    /*
    __display("[%d] >> cache status out: @%x|@%x q: @%x|@%x miss: %b|%b ln: %x|%x ln@: %x|%x  lnw: %b|%b",
                cycle,mem0.addr<<2,mem1.addr<<2,
                qaddr0<<2,qaddr1<<2,
                ~cache0_hit,~cache1_hit,
                cache0_lines.rdata, cache1_lines.rdata,
                cache0_lines.addr, cache1_lines.addr,
                cache0_lines.wenable, cache1_lines.wenable,
                );
    __display("[%d] >> cache status out: todo: %b",cycle,update_lines_todo);
    */
$$if SIMULATION then
    cycle = cycle + 1;
$$end
  }

}

// --------------------------------------------------
