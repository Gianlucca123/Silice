// SL 2020-05 @sylefeb
//
// Pipelined RV32I cpu, see ../CPUs/ice-v-swirl.si for notes
//
// https://github.com/sylefeb/Silice
// MIT license, see LICENSE_MIT in Silice repo root

// Clocks
$$if ICEBREAKER then
$$ICE40 = 1
import('../../common/plls/icebrkr_25_lock.v')
import('../../common/ice40_spram.v')
import('../../common/ice40_sb_gb.v')
$$elseif not SIMULATION then
$$error('This SOC does not support the selected board.')
$$end

$$config['bram_wmask_byte_wenable_width'] = 'data'

$$addrW  = 25
$$periph = addrW - 1
$$ramW   = 24 -- actual memory address width (<= addrW)

// include the processor
$$ICEV_FAST_SHIFT = 1
$$ICEV_MULDIV     = 1
$$ICEV_STALL      = 1
$include('../CPUs/ice-v-swirl.si')

$include('../common/simulation_spram.si')

// QPSRAM
$include('../common/qpsram2x.si')

group bram_io
{
  uint4       wenable(0),
  int32       wdata(0),
  int32       rdata(0),
  uint$addrW$ addr(0),    // boot address
}

// --------------------------------------------------
// Cache
// --------------------------------------------------

$include('swirl-cache.si')

// --------------------------------------------------
// SOC
// --------------------------------------------------

unit main( // I guess this is the SOC :-D
  output uint5 leds,
$$if not VERILATOR then
  inout   uint1 ram_io0,
  inout   uint1 ram_io1,
  inout   uint1 ram_io2,
  inout   uint1 ram_io3,
  output  uint1 ram_clk,
  output  uint1 ram_csn,
  output  uint2 ram_bank(2b00),
$$end
)
$$if not SIMULATION then
<@cpu_clock,!rst> {
  // clock
  uint1 cpu_clock = uninitialized;
  uint1 rst       = uninitialized;
  pll clk_gen (
    clock_in  <: clock,
    clock_out :> cpu_clock,
    reset     :> rst
  );
$$else
{
$$end

	// for memory mapping, need to record prev. cycle addr and rw
	uint$addrW$ prev_mem_addr(0);
	uint1       prev_mem_rw(0);
$$if SIMULATION then
   uint32 cycle(0);  uint32 last_cycle(0);
$$end

$$if VERILATOR then
  // dummy io
  uint1 ram_csn(0); uint1 ram_clk(0); uint1 ram_io0(0); uint1 ram_io1(0);
  uint1 ram_io2(0); uint1 ram_io3(0);
$$end
  bram_io mem0io; bram_io mem1io;
  cache cache(
    ram_csn  :> ram_csn,    ram_clk  :> ram_clk,
    ram_io0 <:> ram_io0,    ram_io1 <:> ram_io1,
    ram_io2 <:> ram_io2,    ram_io3 <:> ram_io3,
    mem0    <:> mem0io,     mem1    <:> mem1io,
  );

  // in-the-middle data interface for peripheral mapping
  bram_io data;

  // cpu
  rv32i_cpu_swirl cpu( imem <:> mem0io, dmem <:> data, stall_cpu <: cache.wait );

  // io mapping
  always_before {
    // ---- memory mapping, masking away peripherals
    uint1 on_periph = data.addr[$periph$,1];
    mem1io.wenable  = on_periph ? 0 : data.wenable;
    mem1io.wdata    = data.wdata;
    mem1io.addr     = on_periph ? mem1io.addr : data.addr;
    data.rdata      = mem1io.rdata;
    // ---- peripherals
$$if SIMULATION then
    if ((data.wenable != 0) & ~on_periph) {
      __display("[cycle %d] write %x @%x",cycle,data.wdata,data.addr);
    }
$$end
    if ((data.wenable != 0) & on_periph) {
$$if SIMULATION then
      if (data.wdata == 32hffffffff) { __finish(); } else
$$end
      {
      switch (data.addr[0,2]) {
        case 1: { leds = data.wdata[0,5];
$$if SIMULATION then
          __display("[cycle %d (%d)] LEDs: %b (%d)",cycle,cycle - last_cycle,leds,data.wdata);
          last_cycle = cycle;
$$end
        }
        case 2: { __write("%c",data.wdata[0,8]); }
      }
      }
    }

$$if SIMULATION then
/*
  $$if false then
    // cache tests
    mem0io.wdata   = 32hfaab0123;
    mem0io.wenable = 4b1111;
    if (~cache.wait) {
      // mem0io.addr    = ((cycle>>2)&1) ? 16384 : 0;
      mem0io.addr    = mem1io.addr >> 1;
      mem1io.addr    = mem1io.addr + 1;
      __display("[%d] 0: %x 1: %x next: 0@%x 1@%x",cycle,mem0io.rdata,mem1io.rdata,mem0io.addr,mem1io.addr);
    }
  $$end
*/
    cycle = cycle + 1;
$$end
  }

  algorithm {
$$if SIMULATION and not BARE then
    while (1) { }
	  //while (cycle < 15000) { }
    //__display("stopping at cycle %d",cycle);
$$else
    while (1) { }
$$end
  }

}

// --------------------------------------------------
