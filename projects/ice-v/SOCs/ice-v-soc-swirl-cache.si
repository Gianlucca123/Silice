// SL 2020-05 @sylefeb
//
// Pipelined RV32I cpu, see ../CPUs/ice-v-swirl.si for notes
//
// https://github.com/sylefeb/Silice
// MIT license, see LICENSE_MIT in Silice repo root

// Clocks
$$if ICEBREAKER then
$$ICE40 = 1
import('../../common/plls/icebrkr_15_lock.v')
import('../../common/ice40_spram.v')
import('../../common/ice40_sb_gb.v')
$$elseif not SIMULATION then
$$error('This SOC does not support the selected board.')
$$end

$$config['bram_wmask_byte_wenable_width'] = 'data'

// pre-compilation script, embeds compiled code within a string
$$data_addr = 4096
$$dofile('pre_include_compiled.lua')

$$addrW = 24
$$ramW  = 24 -- actual memory address width (<= addrW)

// include the processor
$$ICEV_FAST_SHIFT = 1
$$ICEV_MULDIV     = nil
$$ICEV_STALL      = 1
$include('../CPUs/ice-v-swirl.si')

$include('../common/simulation_spram.si')

// QPSRAM
$include('../common/qpsram2x.si')

// --------------------------------------------------
// Cache
// --------------------------------------------------

group bram_io
{
  uint4       wenable(0),
  int32       wdata(0),
  int32       rdata(0),
  uint$addrW$ addr(0),    // boot address
}

interface bram_provider
{
  input   wenable,
  input   wdata,
  output! rdata,
  input   addr,
}

$$cache_line_width      = 10
$$cache_line_size_words = 1<<cache_line_width
$$cache_line_size_bytes = 1<<(cache_line_width+2)
$$num_cache_lines       = 1<<(14-cache_line_width)
$$num_cache_lines_w     = (14-cache_line_width)
$$cache_addr_w          = ramW-cache_line_width

$$print('<<cache configuration>> ' .. num_cache_lines
$$       .. ' cache lines of ' .. cache_line_size_words .. ' int32')

// === cache ===
//
// directly mapped
//
// WARNING: Currently the two caches do not see writes into one another if
//   both are caching the same lines.
//   This is ok when using mem0 for instructions and mem1 for data as long as
//   code is not loaded/generated and then executed. Otherwiwe a software
//   cache flush is required.
// TODO: Implement a mechanism to avoid this issue.
//
unit cache(
  // bram interfaces
  bram_provider mem0,
  bram_provider mem1,
  // wait goes high when cache cannot answer immediately
  output! uint1 wait(1),
  // qpsram io
  inout   uint1 ram_io0,  inout   uint1 ram_io1,
  inout   uint1 ram_io2,  inout   uint1 ram_io3,
  output  uint1 ram_clk,  output  uint1 ram_csn,
) {

  // cache memory (SPRAM)
  //
  // cache for mem0 is spram0,spram1 (2x 16 bits)
  // cache for mem1 is spram2,spram3 (2x 16 bits)
  //
  // each cache stores 16K x int32
  // thus 2^(14 - cache_line_width) lines of 2^cache_line_width int32
$$for n=0,3 do
$$if SIMULATION then
  simulation_spram spram$n$;
$$else
  ice40_spram      spram$n$(clock <: clock);
$$end
$$end

$$init_value=''
$$for b=1,cache_addr_w do
$$  init_value = '1' .. init_value
$$end
$$init_value = (cache_addr_w+1) .. 'b0' .. init_value

  // cache mapping
  bram uint$cache_addr_w+1$ cache0_lines[$num_cache_lines$] = {pad($init_value$)};
  bram uint$cache_addr_w+1$ cache1_lines[$num_cache_lines$] = {pad($init_value$)};
  //                     ^ dirty bit

  // determines whether requested addr match the corresponding cache line
$$for c=0,1 do
  uint$num_cache_lines_w$ line$c$_id    <: mem$c$.addr[$cache_line_width$,$num_cache_lines_w$];
  uint1                   cache$c$_hit <:: qaddr$c$[$cache_line_width$,$cache_addr_w$]
                                        == cache$c$_lines.rdata[0,$cache_addr_w$];
  uint$num_cache_lines_w$ qline$c$_id(0);
  uint$ramW$              qaddr$c$(0);
  uint4                   qwen$c$(0);
$$end

  uint32 cycle(0);

  // external RAM
  qpsram_ram ram(
    ram_csn  :> ram_csn,    ram_clk  :> ram_clk,
    ram_io0 <:> ram_io0,    ram_io1 <:> ram_io1,
    ram_io2 <:> ram_io2,    ram_io3 <:> ram_io3,
  );

  uint1 update_lines_todo(0);
  uint1 update_lines_done(0);

  always_before {
    cache0_lines.addr    = line0_id;
    cache1_lines.addr    = line1_id;
    cache0_lines.wenable = 0;
    cache1_lines.wenable = 0;
    ram.in_ready         = 0; // maintain low, pulse high to read/write
    ram.init             = 0; // maintain low, pulse high to init
    // default lookup
    mem0.rdata           = {spram1.data_out,spram0.data_out};
    mem1.rdata           = {spram3.data_out,spram2.data_out};
    spram0.addr          = {line0_id,:mem0.addr[0,$cache_line_width$]};
    spram1.addr          = {line0_id,:mem0.addr[0,$cache_line_width$]};
    spram2.addr          = {line1_id,:mem1.addr[0,$cache_line_width$]};
    spram3.addr          = {line1_id,:mem1.addr[0,$cache_line_width$]};
    spram0.wmask         = {{2{mem0.wenable[1,1]}},{2{mem0.wenable[0,1]}}};
    spram1.wmask         = {{2{mem0.wenable[3,1]}},{2{mem0.wenable[2,1]}}};
    spram0.wenable       = (|mem0.wenable) & (~wait);
    spram1.wenable       = (|mem0.wenable) & (~wait);
    spram0.data_in       = mem0.wdata[ 0,16];
    spram1.data_in       = mem0.wdata[16,16];
    spram2.wmask         = {{2{mem1.wenable[1,1]}},{2{mem1.wenable[0,1]}}};
    spram3.wmask         = {{2{mem1.wenable[3,1]}},{2{mem1.wenable[2,1]}}};
    spram2.wenable       = (|mem1.wenable) & (~wait);
    spram3.wenable       = (|mem1.wenable) & (~wait);
    spram2.data_in       = mem1.wdata[ 0,16];
    spram3.data_in       = mem1.wdata[16,16];
    // if both caches miss, raise wait
    wait                 = reset | (~cache0_hit|~cache1_hit);
    //                     ^^^^^ wait during reset too
  }

  algorithm <autorun> {

    // init QPSRAM     NOTE: assume already initialized for now
    // ram.init = 1;
    // while (ram.busy) {}
    // main loop

    while (1) {
      if (update_lines_todo) {
        // there is a pending cache miss
        __display("[%d] => cache miss %b|%b %x|%x",cycle,~cache0_hit,~cache1_hit,qaddr0,qaddr1);
        // if line is dirty, store back
        //                  vvvvv start by cache0, then cache1
        uint1 line_dirty = ~cache0_hit ? cache0_lines.rdata[$cache_addr_w$,1]
                                       : cache1_lines.rdata[$cache_addr_w$,1];
        if (line_dirty) {
          // store back line as it was written to
          uint$ramW$ storeAddr =
            ~cache0_hit ? {cache0_lines.rdata,$cache_line_width$b0}
                        : {cache1_lines.rdata,$cache_line_width$b0};
          uint$cache_line_width+2+1$ n = 0;
          __display("[%d] => [cache %b] writing at @%x from line %d",cycle,cache0_hit,storeAddr,~cache0_hit ? qline0_id : qline1_id);
          // write start addr
          ram.addr       = storeAddr;
          while (~n[$cache_line_width+2$,1]) {
            // maintain write status
            ram.in_ready = 1;
            ram.wenable  = 1;
            // vvvvv NOTE: on first iteration spramN.data_out is not ready yet,
            // however the QPSRAM controller does not access it immediately
            //
            // WARNING: watchout if increasing QPSRAM clock at 2x! (may be ok)
            //
            ram.wdata    = ~cache0_hit
                        ? {spram1.data_out,spram0.data_out} >> {n[0,2],3b0}
                        : {spram3.data_out,spram2.data_out} >> {n[0,2],3b0};
            // next?
            if (ram.data_next) {
              //__write("%x,",ram.wdata);
              // next
              n = n + 1;
            }
            // read in cache 0
            spram0.addr    = {qline0_id,n[2,$cache_line_width$]};
            spram1.addr    = {qline0_id,n[2,$cache_line_width$]};
            // read in cache 1
            spram2.addr    = {qline1_id,n[2,$cache_line_width$]};
            spram3.addr    = {qline1_id,n[2,$cache_line_width$]};
          }
          ram.wenable  = 0; // stop writting
          __display(" ");
        }
        // fetch new line
        uint$ramW$ fetchAddr =
          ~cache0_hit ? {qaddr0[$cache_line_width$,$cache_addr_w$],
                                $cache_line_width$b0}
                      : {qaddr1[$cache_line_width$,$cache_addr_w$],
                                $cache_line_width$b0};
        uint$cache_line_width+2+1$ n = 0;
        __display("[%d] +> cache miss %b|%b %x|%x",cycle,~cache0_hit,~cache1_hit,qaddr0,qaddr1);
        __display("[%d] => [cache %b] fetching from @%x in line %d",cycle,cache0_hit,fetchAddr,~cache0_hit ? qline0_id : qline1_id);
        ram.in_ready = 1;
        ram.addr     = fetchAddr;
        while (~n[$cache_line_width+2$,1]) {
          ram.in_ready = 1;
          if (ram.data_next) {
            uint4  wmask   = 2b11 << {n[0,1],1b0};
            uint16 wdata   = ram.rdata << {n[0,1],3b0};
            //__write("%x,",ram.rdata);
            // cache 0
            spram0.addr    = {qline0_id,n[2,$cache_line_width$]};
            spram1.addr    = {qline0_id,n[2,$cache_line_width$]};
            spram0.data_in = wdata;
            spram1.data_in = wdata;
            spram0.wmask   = wmask;
            spram1.wmask   = wmask;
            spram0.wenable = ~cache0_hit & ~n[1,1];
            spram1.wenable = ~cache0_hit &  n[1,1];
            // __write("%b:%x,",spram1.wenable,wdata);
            // cache 1
            spram2.addr    = {qline1_id,n[2,$cache_line_width$]};
            spram3.addr    = {qline1_id,n[2,$cache_line_width$]};
            spram2.data_in = wdata;
            spram3.data_in = wdata;
            spram2.wmask   = wmask;
            spram3.wmask   = wmask;
            spram2.wenable = ~cache1_hit & ~n[1,1];
            spram3.wenable = ~cache1_hit &  n[1,1];
            // next
            n = n + 1;
          }
        }
        __display(" ");
        // update cache register
        if (~cache0_hit) {
          cache0_lines.wdata   = {1b0,qaddr0[$cache_line_width$,$cache_addr_w$]};
          cache0_lines.wenable = 1;
        } else {
          cache1_lines.wdata   = {1b0,qaddr1[$cache_line_width$,$cache_addr_w$]};
          cache1_lines.wenable = 1;
        }
++:     // wait for cache lines bram to be written
        update_lines_done = 1; // done
         __display("[%d] cache done.",cycle);
      } else {
        // no cache miss
        // maintain dirty flag
        cache0_lines.wdata   = {(|qwen0),$cache_addr_w$b0} | cache0_lines.rdata;
        cache0_lines.wenable = 1;
        cache1_lines.wdata   = {(|qwen1),$cache_addr_w$b0} | cache1_lines.rdata;
        cache1_lines.wenable = 1;
      }
    }

  }

  always_after {
    // note that cache lines have to be updated next cycle
    update_lines_todo = ~reset & (~cache0_hit|~cache1_hit) & ~update_lines_done;
    update_lines_done = 0;
    // register inputs from memory interfaces: improves fmax and 'free'
    // as cache update always occurs a cycle after memory interfaces change
    qline0_id = line0_id;     qline1_id = line1_id;
    qaddr0    = mem0.addr;    qaddr1    = mem1.addr;
    qwen0     = mem0.wenable; qwen1     = mem1.wenable;

    cycle = cycle + 1;
  }

}

// --------------------------------------------------
// SOC
// --------------------------------------------------

unit main( // I guess this is the SOC :-D
  output uint5 leds,
$$if not VERILATOR then
  inout   uint1 ram_io0,
  inout   uint1 ram_io1,
  inout   uint1 ram_io2,
  inout   uint1 ram_io3,
  output  uint1 ram_clk,
  output  uint1 ram_csn,
  output  uint2 ram_bank(2b00),
$$end
)
$$if not SIMULATION then
<@cpu_clock,!rst> {
  // clock
  uint1 cpu_clock = uninitialized;
  uint1 rst       = uninitialized;
  pll clk_gen (
    clock_in  <: clock,
    clock_out :> cpu_clock,
    reset     :> rst
  );
$$else
{
$$end

	// for memory mapping, need to record prev. cycle addr and rw
	uint$addrW$ prev_mem_addr(0);
	uint1       prev_mem_rw(0);
$$if SIMULATION then
   uint32 cycle(0);
$$end

$$if VERILATOR then
  // dummy io
  uint1 ram_csn(0); uint1 ram_clk(0); uint1 ram_io0(0); uint1 ram_io1(0);
  uint1 ram_io2(0); uint1 ram_io3(0);
$$end
  bram_io mem0io; bram_io mem1io;
  cache cache(
    ram_csn  :> ram_csn,    ram_clk  :> ram_clk,
    ram_io0 <:> ram_io0,    ram_io1 <:> ram_io1,
    ram_io2 <:> ram_io2,    ram_io3 <:> ram_io3,
    mem0    <:> mem0io,     mem1    <:> mem1io,
  );

  // cpu
//  rv32i_cpu_swirl cpu( imem <:> mem0io, dmem <:> mem1io, stall_cpu <: cache.wait );

  // io mapping
  always_before {
    // ---- memory mapping to peripherals: writes
    if (mem1io.wenable != 0 & mem1io.addr[11,1] & ~cache.wait) {
      leds      = mem1io.wdata[0,5] & {5{mem1io.addr[0,1]}};
$$if SIMULATION then
      if (mem1io.addr[0,1]) {
        __display("[cycle %d] LEDs: %b (%d)",cycle,leds,mem1io.wdata);
        if (mem1io.wdata == 32hffffffff) { __finish(); }
      }
$$end
    }

$$if SIMULATION then
  $$if true then
    // cache tests
    mem0io.wdata   = 32hfaab0123;
    // mem0io.wenable = 41111;
    if (~cache.wait) {
      // mem0io.addr    = ((cycle>>2)&1) ? 16384 : 0;
      mem0io.addr    = mem0io.addr + 256;
      mem1io.addr    = mem1io.addr + 128;
      __display("[%d] 0: %x 1: %x next: 0@%x 1@%x",cycle,mem0io.rdata,mem1io.rdata,mem0io.addr,mem1io.addr);
    }
  $$end
    cycle = cycle + 1;
$$end
  }

  algorithm {
$$if SIMULATION and not BARE then
	  while (cycle < 50000) { }
    __display("stopping at cycle %d",cycle);
    //while (1) { }
$$else
    while (1) { }
$$end
  }

}

// --------------------------------------------------
