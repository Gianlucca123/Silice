// SL 2022-03-16 @sylefeb

// Pre-compilation script, embeds compiled code within a string
$$dofile('pre_include_compiled.lua')


$$periph   = 23    -- bit indicating a peripheral is addressed
$$addrW    = 24    -- additional bits for memory mapping
$$Boot     = 0     -- boot at address zero
$$print('===========> address bus width: ' .. addrW)

// How much BRAM do we allocate
$$bramSize    = 1024

// Main design frequency
$$master_freq = 50

$$if ICEBREAKER or ICEBITSY then
// Import the PLL
import('../common/plls/icebrkr_$master_freq$.v')
import('../common/ice40_half_clock.v')
$$end

// Include the processor
$include('../CPUs/ice-v-dual-fermata.si')

// Include the UART controller
$$uart_in_clock_freq_mhz = 12 -- master_freq//2
$include('../common/uart.si')
$include('../common/clean_reset.si')

$$if ICARUS then
// download W25Q128JVxIM from winbond Verilog models
append('../spiflash/W25Q128JVxIM/W25Q128JVxIM.v')
import('../spiflash/simul_spiflash.v')
$$end

// Include the SPIflash controller
$$nBytes = 4 -- fetches 32 bits words
$include('../spiflash/spiflash2x.si')

// --------------------------------------------------
// RAM
// --------------------------------------------------

// This group holds the signals for the 32-bits RAM ios
group ram_io {
  uint$addrW$ addr(0),     // addr to read from / write to
  uint4       wenable(0),  // write enable mask (one bit per byte)
  uint32      wdata(0),    // 4-bytes to write
  uint32      rdata(0),    // 4-bytes read from memory
  uint1       req_valid(0),// memory request ready (pulse)
  uint1       done(0),     // memory request done (pulse)
}

// --------------
// BRAM implementation of a RAM
unit bram_memory(
  ram_io io {
    input   addr,
    input   wenable,
    input   wdata,
    output! rdata,
    input   req_valid,
    output! done
  }
) {
  // uses template "bram_wmask_byte", that turns wenable into a byte mask
  $$config['bram_wmask_byte_wenable_width'] = 'data'
  bram uint32 mem<"bram_wmask_byte">[$bramSize$] = $meminit$;
  uint1  done(0);
  always {
    io.rdata    = mem.rdata;
    mem.wenable = {4{io.req_valid}} & io.wenable;
    mem.wdata   = io.wdata;
    mem.addr    = io.req_valid ? io.addr : mem.addr;
    io.done     = done;
    done        = io.req_valid;
  }
}

$$if nBytes == 1 then
$$K = 18
$$else
$$K = 18 + (nBytes-1)*2
$$end
circuitry wait() // waits 2+K cycles
{
  uint5 n = 0; while (n != $K$) { n = n + 1; }
}

// --------------
// SPIflash implementation of a RAM (read-only)
unit spiflash_memory(
  ram_io io {
    input   addr,
    input   wenable,
    input   wdata,
    output  rdata,
    input   req_valid,
    output  done,
  },
  output  uint1 init(1), // goes low when SPIflash ctrl is ready
  output  uint1 sf_clk,
  output  uint1 sf_csn,
  inout   uint1 sf_io0,
  inout   uint1 sf_io1,
  inout   uint1 sf_io2,
  inout   uint1 sf_io3,
  output  uint1 uart_tx,
) {

  uart_out    uo;
$$if UART then
  uart_sender usend(
    io      <:> uo,
    uart_tx :>  uart_tx
  );
$$end

  // spiflash
  spiflash_rom sf(
    sf_clk :>  sf_clk,
    sf_csn :>  sf_csn,
    sf_io0 <:> sf_io0,
    sf_io1 <:> sf_io1,
    sf_io2 <:> sf_io2,
    sf_io3 <:> sf_io3,
  );
/*
  uint1  was_busy(0);
  always {
    init        = sf.busy & init;
    io.rdata    = sf.rdata;
    sf.addr     = io.req_valid ? {4b0001,io.addr[0,18],2b00} : sf.addr;
    //                                 ^ offset SPIflash addresses by 1MB
    sf.in_ready = io.req_valid;
    io.done     = was_busy & ~sf.busy;
    was_busy    = sf.busy;
  }
*/
  io.done          := 0;
  sf.in_ready      := 0;
  uo.data_in_ready := 0;
  always_before {
    init        = sf.busy & init;
  }
  algorithm <autorun> {

    subroutine transmit(input uint32 data,readwrites uo)
    {
      uint32 tmp(0);
      uint3 n = 0;
      tmp     = data;
      __display("transmit: %h",data);
      while (~n[2,1]) {
        uo.data_in       = tmp[24,8];
        tmp              = tmp << 8;
        uo.data_in_ready = 1;
        n                = n + 1;
        while (uo.busy) {}
      }
    }

    while (1) {
      if (io.req_valid) {
        sf.addr     = {4b0001,io.addr[0,18],2b00};
        // transmit address
        () <- transmit <- (sf.addr);
        // request data from spiflash
        sf.in_ready = 1;
        // while (sf.busy) { } // wait
        () = wait();
        // transmit data
        () <- transmit <- (sf.rdata);
        // done
        io.rdata = sf.rdata;
        io.done  = 1;
      }
    }
  }

}

// --------------------------------------------------
// PLL for simulation
// --------------------------------------------------

$$if SIMULATION then
algorithm pll(
  output! uint1 clock2x,
  output  uint1 clock1x,
) <autorun> {
  uint2 counter(0);
  clock2x := clock;
  clock1x := ~counter[0,1]; // x2 slower
  always { counter = counter + 1; }
}
$$end

// --------------------------------------------------
// SOC
// --------------------------------------------------

unit main( // I guess this is the SOC :-D
  output uint5 leds,
$$if QSPIFLASH then
  output  uint1 sf_clk,
  output  uint1 sf_csn,
  inout   uint1 sf_io0,
  inout   uint1 sf_io1,
  inout   uint1 sf_io2,
  inout   uint1 sf_io3,
$$end
$$if UART then
  output uint1 uart_tx,
  input  uint1 uart_rx,
$$end
// clocking (pll) and reset
/*
$$if ICEBREAKER or ICEBITSY then
) <@clock1x,!rst> {
  uint1 clock2x = uninitialized;
  pll pllgen(
    clock_in  <: clock,
    clock_out :> clock2x,
  );
  uint1 clock1x  = uninitialized;
  ice40_half_clock hc(
    clock_in  <: clock2x,
    clock_out :> clock1x,
  );
  uint1 rst = uninitialized;
  clean_reset crst<@clock1x,!reset>(
    out :> rst
  );
$$elseif SIMULATION then
 ) <@clock1x> {
  uint1 clock1x = uninitialized;
  uint1 clock2x = uninitialized;
  pll clkgen<@clock,!reset>(
    clock1x :> clock1x,
    clock2x :> clock2x
  );
  uint1 rst <: reset;
$$else
) {
$$end
*/
) {

$$if SIMULATION then
  uint32 cycle(0);
  // for simulation, create dummy spiflash io pads
  uint1 sf_csn(1); uint1 sf_clk(0); uint1 sf_io0(0);
  uint1 sf_io1(0); uint1 sf_io2(0); uint1 sf_io3(0);
  uint1 uart_tx(0);
$$if ICARUS then
  simul_spiflash simu(
    CSn <:  sf_csn, CLK <:  sf_clk, IO0 <:> sf_io0,
    IO1 <:> sf_io1, IO2 <:> sf_io2, IO3 <:> sf_io3,
  );
$$end
$$end

/*
  ram_io mem1io;
  spiflash_memory mem1(io <:> mem1io,
    sf_clk :>  sf_clk, sf_csn :>  sf_csn, sf_io0 <:> sf_io0,
    sf_io1 <:> sf_io1, sf_io2 <:> sf_io2, sf_io3 <:> sf_io3,
    uart_tx :> uart_tx);
  mem1io.req_valid := 0;
  algorithm <autorun> {
    uint9 n = 0;
    while (mem1.init) { }
    mem1io.addr = 0;
    while (n != 64) {
      mem1io.req_valid = 1;
      while (!mem1io.done) {}
      n = n + 1;
      mem1io.addr = mem1io.addr + 1;
    }
  }
*/

  // rams
  // -> bram
  ram_io mem0io;
  bram_memory mem0(io <:> mem0io);
  // -> spiflash
  ram_io mem1io;
  spiflash_memory mem1(io <:> mem1io,
    sf_clk :>  sf_clk, sf_csn :>  sf_csn, sf_io0 <:> sf_io0,
    sf_io1 <:> sf_io1, sf_io2 <:> sf_io2, sf_io3 <:> sf_io3,
    uart_tx :> uart_tx);

  // cpu
  uint1 cpu_rst <: mem1.init;
  icev_dual_fermata cpu<!cpu_rst>(
    mem0 <:> mem0io,
    mem1 <:> mem1io
  );

  always {

    leds = {
      mem1.init,
      2b00,
      mem1io.addr[11,1] & mem1io.req_valid ? mem1io.wdata[0,1] : leds[1,1],
      mem0io.addr[11,1] & mem0io.req_valid ? mem0io.wdata[0,1] : leds[0,1]
    };

    // leds = mem1io.addr[0,5];
    // leds = {5{mem1io.req_valid}};
    // leds[0,1] = mem1.init;

$$if SIMULATION then
    if (mem0io.addr[11,1] & mem0io.req_valid) {
      __display("[cycle %d] LEDS (0) = %h",cycle,mem0io.wdata);
    }
    if (mem1io.addr[11,1] & mem1io.req_valid) {
      __display("[cycle %d] LEDS (1) = %h",cycle,mem1io.wdata);
    }
    if (cycle == 4096) { __finish(); }
    cycle = cycle + 1;
$$end
  }

}

// --------------------------------------------------
