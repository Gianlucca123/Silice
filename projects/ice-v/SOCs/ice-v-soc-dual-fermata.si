// SL 2022-03-16 @sylefeb

// Configures a BRAM template having write mask
$$config['bram_wmask_byte_wenable_width'] = 'data'

// Pre-compilation script, embeds compiled code within a string
$$dofile('pre_include_compiled.lua')

$$periph   = 23    -- bit indicating a peripheral is addressed
$$addrW    = 24    -- additional bits for memory mapping
$$Boot     = 0     -- boot at address zero
$$print('===========> address bus width: ' .. addrW)

// How much BRAM do we allocate (CPU RAM, incl. code)
$$bramSize = 1024
// Verify this is addressable
$$if bramSize > 1<<(addrW-1) then
$$  error("RAM is not fully addressable")
$$end

$$master_freq = 50

$$if ICEBREAKER or ICEBITSY then
// Import the PLL
import('../common/plls/icebrkr_$master_freq$.v')
import('../common/ice40_half_clock.v')
$$end

// Include the processor
$include('../CPUs/ice-v-dual-fermata.si')
// Include SPI
$include('../spiflash/spiflash2.si')
// Include UART
$$uart_in_clock_freq_mhz = master_freq//2
$include('../common/uart.si')

// --------------------------------------------------
// RAM
// --------------------------------------------------

group ram_io {
  uint$addrW$ addr(0),
  uint4       wenable(0),
  uint32      wdata(0),
  uint32      rdata(0),
  uint1       req_valid(0),
  uint1       done(0),
}

unit memory(
  ram_io io {
    input   addr,
    input   wenable,
    input   wdata,
    output! rdata,
    input   req_valid,
    output! done
  }
) {
  // - uses template "bram_wmask_byte", that turns wenable into a byte mask
  bram uint32 mem<"bram_wmask_byte">[$bramSize$] = $meminit$;
  uint1  done(0);
  always {
    io.rdata    = mem.rdata;
    mem.wenable = {4{io.req_valid}} & io.wenable;
    mem.wdata   = io.wdata;
    mem.addr    = io.req_valid ? io.addr : mem.addr;
    io.done     = done;
    done        = io.req_valid;
  }
}

// --------------------------------------------------
// PLL for simulation
// --------------------------------------------------

$$if SIMULATION then
algorithm pll(
  output! uint1 fast_clock,
  output  uint1 cpu_clock,
) <autorun> {
  uint3 counter(0);
  fast_clock := clock;
  cpu_clock  := ~counter[0,1]; // x2 slower
  always { counter = counter + 1; }
}
$$end

// --------------------------------------------------
// SOC
// --------------------------------------------------

unit main( // I guess this is the SOC :-D
  output uint5 leds,
$$if QSPIFLASH then
  output  uint1 sf_clk,
  output  uint1 sf_csn,
  inout   uint1 sf_io0,
  inout   uint1 sf_io1,
  inout   uint1 sf_io2,
  inout   uint1 sf_io3,
$$end
// clocking (pll) and reset
$$if ICEBREAKER or ICEBITSY then
) <@cpu_clock,!fast_reset> {
  uint1 fast_clock = uninitialized;
  pll pllgen(
    clock_in  <: clock,
    clock_out :> fast_clock,
  );
  uint1 cpu_clock  = uninitialized;
  ice40_half_clock hc(
    clock_in  <: fast_clock,
    clock_out :> cpu_clock,
  );
  uint1 fast_reset = uninitialized;
  clean_reset rst<@fast_clock,!reset>(
    out :> fast_reset
  );
$$elseif SIMULATION then
 ) <@cpu_clock> {
  uint1 cpu_clock  = uninitialized;
  uint1 fast_clock = uninitialized;
  pll clkgen<@clock,!reset>(
    cpu_clock  :> cpu_clock,
    fast_clock :> fast_clock
  );
  uint1 fast_reset <: reset;
$$else
) {
$$end

$$if SIMULATION then
   uint32 cycle(0);
$$end

  // rams
  // - intermediate interface to perform memory mapping
  ram_io mem0io;
  ram_io mem1io;

  memory mem0(io <:> mem0io);
  memory mem1(io <:> mem1io);

  // spiflash
  spiflash_rom sf <@fast_clock,!fast_reset, reginputs> (
    sf_clk :>  sf_clk,
    sf_csn :>  sf_csn,
    sf_io0 <:> sf_io0,
    sf_io1 <:> sf_io1,
    sf_io2 <:> sf_io2,
    sf_io3 <:> sf_io3,
  );
$$if SIMULATION then
  // for simulation, create dummy vars
  uint1 sf_csn(1); uint1 sf_clk(0); uint1 sf_io0(0);
  uint1 sf_io1(0); uint1 sf_io2(0); uint1 sf_io3(0);
$$end

  // cpu
  icev_dual_fermata cpu(
    mem0 <:> mem0io,
    mem1 <:> mem1io
  );

  always_before {
$$if SIMULATION then
    cycle = cycle + 1;
$$end
  }

  algorithm <autorun> {
$$if SIMULATION then
    // stop after some cycles
	  while (cycle < 1024) { }
$$else
    // CPU is running
    while (1) { }
$$end
  }

}

// --------------------------------------------------

$$if OLED or PMOD then
$$OLED_SLOW = 1
$include('ice-v-oled.si')
$$end

// --------------------------------------------------

$$if PMOD then
$include('ice-v-i2s-audio.si')
$$end

// --------------------------------------------------
