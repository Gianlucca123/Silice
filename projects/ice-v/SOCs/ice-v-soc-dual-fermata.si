// SL 2022-03-16 @sylefeb

$$addrW    = 20         -- additional bits for memory mapping
$$periph   = addrW-1    -- bit indicating a peripheral is addressed
$$Boot     = 0x100000   -- boot at 1MB (spiflash)
$$print('===========> address bus width: ' .. addrW)

// How much BRAM do we allocate
$$bramSize    = 1024

// Main design frequency
$$master_freq = 50

$$if ICEBREAKER or ICEBITSY then
// Import the PLL
import('../common/plls/icebrkr_$master_freq$.v')
import('../common/ice40_half_clock.v')
$$end

// Include the processor
$$ICEV_FAST_SHIFT = nil
$$ICEV_MULDIV     = nil
$$ICEV_USERDATA   = nil
$include('../CPUs/ice-v-dual-fermata.si')

// Include the UART controller
$$uart_in_clock_freq_mhz = 12 -- master_freq//2
$include('../common/uart.si')
$include('../common/clean_reset.si')

$$if ICARUS then
// download W25Q128JVxIM from winbond Verilog models
append('../spiflash/W25Q128JVxIM/W25Q128JVxIM.v')
import('../spiflash/simul_spiflash.v')
$$end

// Include the SPIflash controller
$$nBytes = 4 -- fetches 32 bits words
$include('../spiflash/spiflash2x.si')

// --------------------------------------------------
// RAM
// --------------------------------------------------

// This group holds the signals for the 32-bits RAM ios
group ram_io {
  uint$addrW$ addr(0),     // addr to read from / write to
  uint4       wenable(0),  // write enable mask (one bit per byte)
  uint32      wdata(0),    // 4-bytes to write
  uint32      rdata(0),    // 4-bytes read from memory
  uint1       req_valid(0),// memory request ready (pulse)
  uint1       done(0),     // memory request done (pulse)
}

interface ram_provider {
  input   addr,
  input   wenable,
  input   wdata,
  output! rdata,
  input   req_valid,
  output! done
}

// --------------
// BRAM implementation of a RAM
unit bram_memory(ram_provider io) {
  // uses template "bram_wmask_byte", that turns wenable into a byte mask
  $$config['bram_wmask_byte_wenable_width'] = 'data'
  bram uint32 mem<"bram_wmask_byte">[$bramSize$] = uninitialized; // meminit;
  uint1  done(0);
  always {
    io.rdata    = mem.rdata;
    mem.wenable = {4{io.req_valid}} & io.wenable;
    mem.wdata   = io.wdata;
    mem.addr    = io.req_valid ? io.addr : mem.addr;
    io.done     = done;
    done        = io.req_valid;
  }
}

// --------------
// SPIflash implementation of a ROM
unit spiflash_memory(
  ram_provider io,
  output  uint1 init(1), // goes low when SPIflash ctrl is ready
  output  uint1 sf_clk,  output  uint1 sf_csn,
  inout   uint1 sf_io0,  inout   uint1 sf_io1,
  inout   uint1 sf_io2,  inout   uint1 sf_io3,
) {
  // spiflash rom
  spiflash_rom sf(
    sf_clk :>  sf_clk,   sf_csn :>  sf_csn,
    sf_io0 <:> sf_io0,   sf_io1 <:> sf_io1,
    sf_io2 <:> sf_io2,   sf_io3 <:> sf_io3,
  );
  // logic
  uint1  was_busy(0);
  always {
    init        = sf.busy & init;
    io.rdata    = sf.rdata;
    sf.addr     = io.req_valid ? {4b0001,io.addr[0,18],2b00} : sf.addr;
    //                                 ^ offset SPIflash addresses by 1MB
    sf.in_ready = io.req_valid;
    io.done     = was_busy & ~sf.busy;
    was_busy    = sf.busy;
  }
}

// --------------
// Debug SPIflash implementation of a ROM
// Transmits addr and read 32 bits words over UART

unit spiflash_memory_uart_debug(
  ram_provider io,
  output  uint1 init(1), // goes low when SPIflash ctrl is ready
  output  uint1 sf_clk,
  output  uint1 sf_csn,
  inout   uint1 sf_io0,
  inout   uint1 sf_io1,
  inout   uint1 sf_io2,
  inout   uint1 sf_io3,
  output  uint1 uart_tx,
) {

  uart_out    uo;
$$if UART then
  uart_sender usend(
    io      <:> uo,
    uart_tx :>  uart_tx
  );
$$end

  // spiflash
  spiflash_rom sf(
    sf_clk :>  sf_clk,
    sf_csn :>  sf_csn,
    sf_io0 <:> sf_io0,
    sf_io1 <:> sf_io1,
    sf_io2 <:> sf_io2,
    sf_io3 <:> sf_io3,
  );

  io.done          := 0;
  sf.in_ready      := 0;
  uo.data_in_ready := 0;
  always_before {
    init        = sf.busy & init;
  }
  algorithm <autorun> {

    subroutine transmit(input uint32 data,readwrites uo)
    {
      uint32 tmp(0);
      uint3 n = 0;
      tmp     = data;
      __display("transmit: %h",data);
      while (~n[2,1]) {
        uo.data_in       = tmp[24,8];
        tmp              = tmp << 8;
        uo.data_in_ready = 1;
        n                = n + 1;
        while (uo.busy) {}
      }
    }

    while (1) {
      if (io.req_valid) {
        sf.addr     = {4b0001,io.addr[0,18],2b00};
        // transmit address
        () <- transmit <- (sf.addr);
        // request data from spiflash
        sf.in_ready = 1;
        while (sf.busy) { } // wait
        // transmit data
        () <- transmit <- (sf.rdata);
        // done
        io.rdata = sf.rdata;
        io.done  = 1;
      }
    }
  }

}

// --------------
// Implementation of a composite RAM
// - ROM mapped from 0x100000 (1MB)
// - RAM is assumed to be BRAM (1-cycle latency)
// - ROM is assumed slow
// - expects io0 and io1 to be well behaved:
//   + do not request access again before receiving done
//   + maintain request data while not fullfilled
unit composite_memory(
  icev_ram_user ram,
  icev_ram_user rom,
  ram_provider  io0,
  ram_provider  io1
) {
  uint1            rom0_req_valid(0);
  uint1            rom1_req_valid(0);
  uint1            rom_busy(0);
  uint1            rom_client(0);
  always {
    uint1 io0_in_ram_now <: ~io0.addr[18,1]; //_ from 0x100000 (1MB)
    uint1 io1_in_ram_now <: ~io1.addr[18,1];
    uint1 io0_was_in_ram(0);
    uint1 io1_was_in_ram(0);
    /// RAM access
    // NOTE: assumes io0 and io1 cannot concurrently access RAM, true on the ice-v
    ram.addr       = io0_in_ram_now ? io0.addr    : io1.addr;
    ram.wenable    = io0_in_ram_now ? io0.wenable : io1.wenable;
    ram.wdata      = io0_in_ram_now ? io0.wdata   : io1.wdata;
    ram.req_valid  = (io0_in_ram_now & io0.req_valid) | (io1_in_ram_now & io1.req_valid);
    // ROM access (may be concurrent, io0/io1 can overlap requests)
    // -> maintain requests low
    rom.req_valid  = 0;
    // -> get results
    io0.rdata = ( rom.done & ~io0_was_in_ram) ? rom.rdata
              : ((ram.done &  io0_was_in_ram) ? ram.rdata : io0.rdata);
    io1.rdata = ( rom.done & ~io1_was_in_ram) ? rom.rdata
              : ((ram.done &  io1_was_in_ram) ? ram.rdata : io1.rdata);
    io0.done  =  (rom.done & ~rom_client) | (ram.done & io0_was_in_ram);
    io1.done  =  (rom.done &  rom_client) | (ram.done & io1_was_in_ram);
    // -> send next, 0 has higher priority
    if (rom.done) {
      rom_busy       = 0;
      __display("========================== ROM done client:%b, pending: %b|%b",
        rom_client,rom0_req_valid,rom1_req_valid);
    }
    // -> capture requests (will be dealt with asap)
    rom0_req_valid = io0.req_valid ? ~io0_in_ram_now : rom0_req_valid;
    rom1_req_valid = io1.req_valid ? ~io1_in_ram_now : rom1_req_valid;
    if (rom0_req_valid & ~rom_busy) {
      __display("========================== io0 ROM request");
      rom.addr       = io0.addr;
      rom.req_valid  = 1;
      rom0_req_valid = 0;
      rom_busy       = 1;
      rom_client     = 0;
    } else {
      if (rom1_req_valid & ~rom_busy) {
        __display("========================== io1 ROM request");
        rom.addr       = io1.addr;
        rom.req_valid  = 1;
        rom1_req_valid = 0;
        rom_busy       = 1;
        rom_client     = 1;
      }
    }
    // record who was accessing what at the previous cycle
    io0_was_in_ram = io0_in_ram_now;
    io1_was_in_ram = io1_in_ram_now;
  }
}

// --------------------------------------------------
// PLL for simulation
// --------------------------------------------------

$$if SIMULATION then
algorithm pll(
  output! uint1 clock2x,
  output  uint1 clock1x,
) <autorun> {
  uint2 counter(0);
  clock2x := clock;
  clock1x := ~counter[0,1]; // x2 slower
  always { counter = counter + 1; }
}
$$end

// --------------------------------------------------
// SOC
// --------------------------------------------------

unit main( // I guess this is the SOC :-D
  output uint5 leds,
$$if QSPIFLASH then
  output  uint1 sf_clk,
  output  uint1 sf_csn,
  inout   uint1 sf_io0,
  inout   uint1 sf_io1,
  inout   uint1 sf_io2,
  inout   uint1 sf_io3,
$$end
$$if UART then
  output uint1 uart_tx,
  input  uint1 uart_rx,
$$end
// clocking (pll) and reset
/*
$$if ICEBREAKER or ICEBITSY then
) <@clock1x,!rst> {
  uint1 clock2x = uninitialized;
  pll pllgen(
    clock_in  <: clock,
    clock_out :> clock2x,
  );
  uint1 clock1x  = uninitialized;
  ice40_half_clock hc(
    clock_in  <: clock2x,
    clock_out :> clock1x,
  );
  uint1 rst = uninitialized;
  clean_reset crst<@clock1x,!reset>(
    out :> rst
  );
$$elseif SIMULATION then
 ) <@clock1x> {
  uint1 clock1x = uninitialized;
  uint1 clock2x = uninitialized;
  pll clkgen<@clock,!reset>(
    clock1x :> clock1x,
    clock2x :> clock2x
  );
  uint1 rst <: reset;
$$else
) {
$$end
*/
) {

$$if SIMULATION then
  uint32 cycle(0);
  // for simulation, create dummy spiflash io pads
  uint1 sf_csn(1); uint1 sf_clk(0); uint1 sf_io0(0);
  uint1 sf_io1(0); uint1 sf_io2(0); uint1 sf_io3(0);
  uint1 uart_tx(0);
$$if ICARUS then
  simul_spiflash simu(
    CSn <:  sf_csn, CLK <:  sf_clk, IO0 <:> sf_io0,
    IO1 <:> sf_io1, IO2 <:> sf_io2, IO3 <:> sf_io3,
  );
$$end
$$end

  // ---- memory
  // -> bram
  ram_io ram;
  bram_memory mem0(io <:> ram);
  // -> spiflash
  ram_io rom;
  spiflash_memory mem1(io <:> rom,
  // spiflash_memory_uart_debug mem1(io <:> rom,
    sf_clk :>  sf_clk, sf_csn :>  sf_csn, sf_io0 <:> sf_io0,
    sf_io1 <:> sf_io1, sf_io2 <:> sf_io2, sf_io3 <:> sf_io3,
  );
  // uart_tx :> uart_tx);
  uint1 sys_rst <: mem1.init; // system reset when spiflash is ready
  // -> composite
  ram_io mem0io;
  ram_io mem1io;
  composite_memory mem<!sys_rst>(
    ram <:> ram,    rom <:> rom,
    io0 <:> mem0io, io1 <:> mem1io,
  );

  // ---- cpu
  icev_dual_fermata cpu<!sys_rst>( mem0 <:> mem0io, mem1 <:> mem1io );

  always {

    leds = mem1io.addr[$periph$,1] & mem1io.req_valid ? mem1io.wdata : leds;

$$if SIMULATION then
    if (mem0io.addr[$periph$,1] & mem0io.req_valid) {
      __display("[cycle %d] LEDS (0) = %h",cycle,mem0io.wdata);
    }
    if (mem1io.addr[$periph$,1] & mem1io.req_valid) {
      __display("[cycle %d] LEDS (1) = %h",cycle,mem1io.wdata);
    }
    if (cycle == 16000) { __finish(); }
    cycle = cycle + 1;
$$end
  }

}

// --------------------------------------------------
