// SL 2022-03-16 @sylefeb

// Configures a BRAM template having write mask
$$config['bram_wmask_byte_wenable_width'] = 'data'

// Pre-compilation script, embeds compiled code within a string
$$dofile('pre_include_compiled.lua')

$$periph   = 23    -- bit indicating a peripheral is addressed
$$addrW    = 24    -- additional bits for memory mapping
$$Boot     = 0     -- boot at address zero
$$print('===========> address bus width: ' .. addrW)

// How much BRAM do we allocate (CPU RAM, incl. code)
$$bramSize = 1024
// Verify this is addressable
$$if bramSize > 1<<(addrW-1) then
$$  error("RAM is not fully addressable")
$$end

$$master_freq = 50
// Import the PLL
import('../common/plls/icebrkr_$master_freq$.v')
import('../common/ice40_half_clock.v')

// Include the processor
$include('../CPUs/ice-v-dual-fermata.si')
// Include SPI
$include('../spiflash/spiflash2.si')
// Include UART
$$uart_in_clock_freq_mhz = master_freq//2
$include('../common/uart.si')

// --------------------------------------------------
// RAM
// --------------------------------------------------

group ram_io {
  uint$addrW$ addr(0),
  uint4       wenable(0),
  uint32      wdata(0),
  uint32      rdata(0),
  uint1       req_valid(0),
  uint1       done(0),
}

unit memory(
  ram_io io {
    input  addr,
    input  wenable,
    input  wdata,
    output rdata,
    input  req_valid,
    output done
  }
) {
  // - uses template "bram_wmask_byte", that turns wenable into a byte mask
  bram uint32 mem<"bram_wmask_byte">[$bramSize$] = $meminit$;
  uint1  done(0);
  always {
    io.rdata    = mem.rdata;
    mem.wenable = {4{io.req_valid}} & io.wenable;
    mem.wdata   = io.wdata;
    mem.addr    = io.req_valid ? io.addr : mem.addr;
    io.done     = done;
    done        = io.req_valid;
  }
}

// --------------------------------------------------
// SOC
// --------------------------------------------------

unit main( // I guess this is the SOC :-D
  output uint5 leds,
) {

$$if SIMULATION then
   uint32 cycle(0);
$$end

  // rams
  // - intermediate interface to perform memory mapping
  ram_io mem0io;
  ram_io mem1io;

  memory mem0(io <:> mem0io);
  memory mem1(io <:> mem1io);

  // cpu
  icev_dual_fermata cpu(
    mem0 <:> mem0io,
    mem1 <:> mem1io
  );

  // io mapping
  always_before {
$$if SIMULATION then
    cycle = cycle + 1;
$$end
  }

  algorithm <autorun> {
$$if SIMULATION then
    // stop after some cycles
	  while (cycle < 1024) { }
$$else
    // CPU is running
    while (1) { }
$$end
  }

}

// --------------------------------------------------

$$if OLED or PMOD then
$$OLED_SLOW = 1
$include('ice-v-oled.si')
$$end

// --------------------------------------------------

$$if PMOD then
$include('ice-v-i2s-audio.si')
$$end

// --------------------------------------------------
