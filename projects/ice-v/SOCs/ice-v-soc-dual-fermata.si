// SL 2022-03-16 @sylefeb

$$addrW    = 20         -- additional bits for memory mapping
$$periph   = addrW-1    -- bit indicating a peripheral is addressed
$$Boot     = 0x100000   -- boot at 1MB (spiflash)
$$print('===========> address bus width: ' .. addrW)

// How much BRAM do we allocate
$$bramSize    = 1024

// Main design frequency
$$master_freq = 50

$$if ICEBREAKER or ICEBITSY or FOMU then
$$UP5K = 1
// Import the PLL
import('../common/plls/icebrkr_$master_freq$.v')
import('../common/ice40_half_clock.v')
import('../../common/ice40_spram.v')
$$elseif SIMULATION then
$include('../../common/simulation_spram.si')
$$else
$$error('uho, this SOC is for simulation or UP5K only')
$$end

// Include the processor
$$ICEV_FAST_SHIFT = nil
$$ICEV_MULDIV     = nil
$$ICEV_USERDATA   = nil
$include('../CPUs/ice-v-dual-fermata.si')

// Include the UART controller
$$uart_in_clock_freq_mhz = master_freq//2
$include('../common/uart.si')
$include('../common/clean_reset.si')

$$if ICARUS then
// download W25Q128JVxIM from winbond Verilog models
append('../spiflash/W25Q128JVxIM/W25Q128JVxIM.v')
import('../spiflash/simul_spiflash.v')
$$end

// Include the SPIflash controller
$$nBytes = 4 -- fetches 32 bits words
$include('../spiflash/spiflash2x.si')

// --------------------------------------------------
// RAM
// --------------------------------------------------

// This group holds the signals for the 32-bits RAM ios
group ram_io {
  uint$addrW$ addr(0),     // addr to read from / write to
  uint4       wenable(0),  // write enable mask (one bit per byte)
  uint32      wdata(0),    // 4-bytes to write
  uint32      rdata(0),    // 4-bytes read from memory
  uint1       req_valid(0),// memory request ready (pulse)
  uint1       done(0),     // memory request done (pulse)
}

interface ram_provider {
  input   addr,
  input   wenable,
  input   wdata,
  output! rdata,
  input   req_valid,
  output! done
}

// --------------
// BRAM implementation of a RAM
unit bram_memory(ram_provider io) {
  // uses template "bram_wmask_byte", that turns wenable into a byte mask
  $$config['bram_wmask_byte_wenable_width'] = 'data'
  bram uint32 mem<"bram_wmask_byte">[$bramSize$] = uninitialized; // meminit;
  uint1  done(0);
  always {
    io.rdata    = mem.rdata;
    mem.wenable = {4{io.req_valid}} & io.wenable;
    mem.wdata   = io.wdata;
    mem.addr    = io.req_valid ? io.addr : mem.addr;
    io.done     = done;
    done        = io.req_valid;
  }
}

// --------------
// SPRAM implementation of a RAM
$$if UP5K or SIMULATION then
unit spram_memory(ram_provider io) {
  uint14 sp0_addr(0);    uint4  sp0_wmask(0);    uint1  sp0_wenable(0);
  uint16 sp0_data_in(0); uint16 sp0_data_out(0);
  uint14 sp1_addr(0);    uint4  sp1_wmask(0);    uint1  sp1_wenable(0);
  uint16 sp1_data_in(0); uint16 sp1_data_out(0);
$$if SIMULATION then
  simulation_spram spram0(
$$else
  ice40_spram      spram0(clock    <: clock,
$$end
    addr    <: sp0_addr,    data_in <: sp0_data_in, data_out :> sp0_data_out,
    wenable <: sp0_wenable, wmask   <: sp0_wmask,
  );
$$if SIMULATION then
  simulation_spram spram1(
$$else
  ice40_spram      spram1(clock    <: clock,
$$end
    addr    <: sp1_addr,    data_in <: sp1_data_in, data_out :> sp1_data_out,
    wenable <: sp1_wenable, wmask   <: sp1_wmask,
  );
  uint1  done(0);
  always {
    sp0_data_in   = io.wdata[ 0,16];
    sp1_data_in   = io.wdata[16,16];
    sp0_addr      = io.addr[0,14];
    sp1_addr      = io.addr[0,14];
    sp0_wmask     = {io.wenable[1,1],io.wenable[1,1],io.wenable[0,1],io.wenable[0,1]};
    sp1_wmask     = {io.wenable[3,1],io.wenable[3,1],io.wenable[2,1],io.wenable[2,1]};
    sp0_wenable   = io.req_valid & (io.wenable != 0);
    sp1_wenable   = io.req_valid & (io.wenable != 0);
    io.rdata      = {sp1_data_out,sp0_data_out};
    io.done       = done;
    done          = io.req_valid;
  }
}
$$end

// --------------
// SPIflash implementation of a ROM
unit spiflash_memory(
  ram_provider io,
  output  uint1 init(1), // goes low when SPIflash ctrl is ready
  output  uint1 sf_clk,  output  uint1 sf_csn,
  inout   uint1 sf_io0,  inout   uint1 sf_io1,
  inout   uint1 sf_io2,  inout   uint1 sf_io3,
) {
  // spiflash rom
  spiflash_rom sf(
    sf_clk :>  sf_clk,   sf_csn :>  sf_csn,
    sf_io0 <:> sf_io0,   sf_io1 <:> sf_io1,
    sf_io2 <:> sf_io2,   sf_io3 <:> sf_io3,
  );
  // logic
  uint1  was_busy(0);
  always {
    init        = sf.busy & init;
    io.rdata    = sf.rdata;
    sf.addr     = io.req_valid ? {4b0001,io.addr[0,18],2b00} : sf.addr;
    //                                 ^ offset SPIflash addresses by 1MB
    sf.in_ready = io.req_valid;
    io.done     = was_busy & ~sf.busy;
    was_busy    = sf.busy;
  }
}

// --------------
// Implementation of a composite RAM
// - ROM mapped from 0x100000 (1MB)
// - RAM is assumed to be BRAM (1-cycle latency)
// - ROM is assumed slow
// - expects io0 and io1 to be well behaved:
//   + do not request access again before receiving done
//   + maintain request data while not fullfilled
unit composite_memory(
  icev_ram_user ram,
  icev_ram_user rom,
  ram_provider  io0,
  ram_provider  io1
) {
  uint1            rom0_req_valid(0);
  uint1            rom1_req_valid(0);
  uint1            rom_busy(0);
  uint1            rom_client(0);
  always {
    uint1 io0_in_ram_now <: ~io0.addr[18,1]; //_ from 0x100000 (1MB)
    uint1 io1_in_ram_now <: ~io1.addr[18,1];
    uint1 io0_was_in_ram(0);
    uint1 io1_was_in_ram(0);
    /// RAM access
    // NOTE: assumes io0 and io1 cannot concurrently access RAM, true on the ice-v
    ram.addr       = io0_in_ram_now ? io0.addr    : io1.addr;
    ram.wenable    = io0_in_ram_now ? io0.wenable : io1.wenable;
    ram.wdata      = io0_in_ram_now ? io0.wdata   : io1.wdata;
    ram.req_valid  = (io0_in_ram_now & io0.req_valid) | (io1_in_ram_now & io1.req_valid);
    // ROM access (may be concurrent, io0/io1 can overlap requests)
    // -> maintain requests low
    rom.req_valid  = 0;
    // -> get results
    io0.rdata = ( rom.done & ~io0_was_in_ram) ? rom.rdata
              : ((ram.done &  io0_was_in_ram) ? ram.rdata : io0.rdata);
    io1.rdata = ( rom.done & ~io1_was_in_ram) ? rom.rdata
              : ((ram.done &  io1_was_in_ram) ? ram.rdata : io1.rdata);
    io0.done  =  (rom.done & ~rom_client) | (ram.done & io0_was_in_ram);
    io1.done  =  (rom.done &  rom_client) | (ram.done & io1_was_in_ram);
    // -> send next, 0 has higher priority
    if (rom.done) {
      rom_busy       = 0;
    }
    // -> capture requests (will be dealt with asap)
    rom0_req_valid = io0.req_valid ? ~io0_in_ram_now : rom0_req_valid;
    rom1_req_valid = io1.req_valid ? ~io1_in_ram_now : rom1_req_valid;
    if (rom0_req_valid & ~rom_busy) {
      rom.addr       = io0.addr;
      rom.req_valid  = 1;
      rom0_req_valid = 0;
      rom_busy       = 1;
      rom_client     = 0;
    } else {
      if (rom1_req_valid & ~rom_busy) {
        rom.addr       = io1.addr;
        rom.req_valid  = 1;
        rom1_req_valid = 0;
        rom_busy       = 1;
        rom_client     = 1;
      }
    }
    // record who was accessing what at the previous cycle
    io0_was_in_ram = io0_in_ram_now;
    io1_was_in_ram = io1_in_ram_now;
  }
}

// --------------------------------------------------
// PLL for simulation
// --------------------------------------------------

$$if SIMULATION then
algorithm pll(
  output! uint1 clock2x,
  output  uint1 clock1x,
) <autorun> {
  uint2 counter(0);
  clock2x := clock;
  clock1x := ~counter[0,1]; // x2 slower
  always { counter = counter + 1; }
}
$$end

// --------------------------------------------------
// SOC
// --------------------------------------------------

unit main( // I guess this is the SOC :-D
  output uint5 leds,
$$if QSPIFLASH then
  output  uint1 sf_clk,
  output  uint1 sf_csn,
  inout   uint1 sf_io0,
  inout   uint1 sf_io1,
  inout   uint1 sf_io2,
  inout   uint1 sf_io3,
$$end
$$if UART then
  output uint1 uart_tx,
  input  uint1 uart_rx,
$$end
// clocking (pll) and reset
$$if ICEBREAKER or ICEBITSY then
) <@clock1x,!rst> {
  uint1 clock2x = uninitialized;
  pll pllgen(
    clock_in  <: clock,
    clock_out :> clock2x,
  );
  uint1 clock1x  = uninitialized;
  ice40_half_clock hc(
    clock_in  <: clock2x,
    clock_out :> clock1x,
  );
  uint1 rst = uninitialized;
  clean_reset crst<@clock1x,!reset>(
    out :> rst
  );
$$elseif SIMULATION then
 ) <@clock1x> {
  uint1 clock1x = uninitialized;
  uint1 clock2x = uninitialized;
  pll clkgen<@clock,!reset>(
    clock1x :> clock1x,
    clock2x :> clock2x
  );
  uint1 rst <: reset;
$$else
) {
$$end

$$if SIMULATION then
  uint32 cycle(0);
  // for simulation, create dummy spiflash io pads
  uint1 sf_csn(1); uint1 sf_clk(0); uint1 sf_io0(0);
  uint1 sf_io1(0); uint1 sf_io2(0); uint1 sf_io3(0);
  uint1 uart_tx(0);
$$if ICARUS then
  simul_spiflash simu(
    CSn <:  sf_csn, CLK <:  sf_clk, IO0 <:> sf_io0,
    IO1 <:> sf_io1, IO2 <:> sf_io2, IO3 <:> sf_io3,
  );
$$end
$$end

  // ---- memory
  // -> bram
  ram_io spram;
  spram_memory mem0(io <:> spram);
  // -> spiflash
  ram_io spflash;
  spiflash_memory mem1(io <:> spflash,
    sf_clk :>  sf_clk, sf_csn :>  sf_csn, sf_io0 <:> sf_io0,
    sf_io1 <:> sf_io1, sf_io2 <:> sf_io2, sf_io3 <:> sf_io3,
  );
  uint1 sys_rst <: mem1.init; // system reset when spiflash is ready

  // ---- composite memory
  ram_io mem0io;
  ram_io mem1io;
  composite_memory mem<!sys_rst>(
    ram <:> spram,  rom <:> spflash,
    io0 <:> mem0io, io1 <:> mem1io,
  );
  // ---- cpu
  icev_dual_fermata cpu<!sys_rst>(
    mem0 <:> mem0io,
    mem1 <:> mem1io
  );

  always {

    leds = mem1io.addr[$periph$,1] & mem1io.req_valid
         ? mem1io.wdata
         : mem0io.addr[$periph$,1] & mem0io.req_valid
         ? mem0io.wdata
         : leds;

$$if SIMULATION then
    if (mem0io.addr[$periph$,1] & mem0io.req_valid) {
      __display("[cycle %d] LEDS (0) = %h",cycle,mem0io.wdata);
    }
    if (mem1io.addr[$periph$,1] & mem1io.req_valid) {
      __display("[cycle %d] LEDS (1) = %h",cycle,mem1io.wdata);
    }
    if (cycle == 16000) { __finish(); }
    cycle = cycle + 1;
$$end
  }

}

// --------------------------------------------------
