\documentclass[a4]{article}

\usepackage{hyperref}
\usepackage{a4wide}
\usepackage{minted}
\usepackage{xcolor}
\usepackage{calc}

\newcommand\todo[1]{{\color{magenta}\textbf{TODO:} #1}}
\newcommand\verilog{Verilog}
\newcommand\silice{Silice}

% enamel

\title{\silice{}\\ \textit{\normalsize A language for hardcoding Algorithms into FPGA hardware}}

\begin{document}

\maketitle

\silice{} makes it possible to write algorithms for FPGAs in the same way we write them for processors: defining sequences of operations, subroutines that can be called, and using control flow statements such as \texttt{while} and \texttt{break} (even good old \texttt{goto}s are available!). 
At the same time, \silice{} lets you fully exploit the parallelism and niceties of FPGA architectures, describing operations and algorithms that run in parallel and are always active, as well as pipelines.
\silice{} \textit{remains close to the hardware}. When writing an algorithm you are in control of what happens at which clock cycle, with predictable rules for flow control. Clock domains are exposed. 

\silice{} is only a thin layer above the hardware: nothing gets obfuscated away. In fact, \silice{} compiles to and inter-operates with \verilog{}: you can directly instantiate and bind with existing modules. When \verilog{} makes more sense, use it!

\silice{} is reminiscent of high performance programming in the late 90s (in the demo scene in particular): the then considered high-level C language was commonly interfaced with time-critical ASM routines. This enabled a best-of-both-worlds situation, with C being used for the overall program flow and ASM used only on carefully optimized hardware dependent routines.
%
\silice{} aims to do the same, providing a thin programmer friendly layer on top of \verilog{}, while allowing to call low level \verilog{} modules whenever needed.
\silice{} also favors and exposes parallelism, so as to fully utilize the FPGA architecture.\\

Oh, and it features a powerful LUA-based pre-processor.\\

\noindent While I developed \silice{} for my own needs, I hope you'll find it useful for your projects!

\vspace*{5mm}
\noindent
{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{GitHub repository: \url{https://github.com/sylefeb/Silice/}}}\\

% ==============================================
	
\section{A first example}

This first example assumes two signals: a 'button' input (high when pressed) and a 'led' output, each one bit.

The \textit{main} algorithm -- the one expected as top level -- simply asks the led to turn on when the button is pressed. We will consider several versions -- all working -- to demonstrate basic features of \silice{}.

Perhaps the most natural version for a programmer not used to FPGAs would be:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main(input uint1 button,output uint1 led) {  
  while (1) {
    led = button;
  }
}
\end{minted}
This sets 'led' to the value of 'button' every clock cycle.
%
However, we could instead specify a \textit{continuous assignment} between led and button:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main(input uint1 button,output uint1 led) {  
  led := button;
}
\end{minted}

This makes 'led' constantly track the value of 'button'. A very convenient feature is that the continuous assignment can be overridden at some clock steps, for instance:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main(input uint1 button,output uint1 led) {  
  led := 0;
  while (1) {
    if (button == 1) {
      led = 1;
    }
  }  
}
\end{minted}

Of course this last version is needlessly complicated (the previous one was minimal), but it shows the principle: 'led' is continuously assigned 0, but this will be overridden whenever the button is pressed. This is useful to maintain an output to a value that must change only on some specific event (e.g. producing a pulse).

% ==============================================

\tableofcontents

% ==============================================

\section{Terminology}
Some terminology we use next:
\begin{itemize}
\item \textbf{VIO}: a Variable, Input or Output.
\item \textbf{Combinational chain}: A chain of dependent operations implemented
as combinational hardware.
\item \textbf{Combinational loop}: A combinational chain where a cyclic dependency exists. These lead to unstable hardware synthesis and have to be avoided (but in a few rare cases).
\item \textbf{Host hardware framework}: The \verilog{} glue to the hardware meant to run the design. This can also be a glue to Icarus\footnote{http://iverilog.icarus.com/} or Verilator\footnote{https://www.veripool.org/wiki/verilator}, both frameworks are provided.
\end{itemize}

% ==============================================

\section{Basic language constructs}

\subsection{Types}
\label{sec:types}

\silice{} supports signed and unsigned integers with a specified bit width:

\begin{itemize}
	\item \texttt{int}N with N the bit-width, e.g. \texttt{int8}: signed integer.
	\item \texttt{uint}N with N the bit-width, e.g. \texttt{uint8}: unsigned integer.
\end{itemize}

% --------------------------

\subsection{Constants}
\label{sec:csts}

Constants may be given directly as decimal based numbers (eg. \texttt{1234}), or
can be given with a specified bit width and base:
\begin{itemize}
	\item \texttt{3b0101}, 3 bits wide value 5.
	\item \texttt{32hffff}, 32 bits wide value 65535.
	\item \texttt{4d10}, 4 bits wide value 10.
\end{itemize}

Supported base identifiers are: \texttt{b} for binary, \texttt{h} for hexadecimal, \texttt{d} for decimal. If the value does not fit the bit width, it is clamped.

% --------------------------

\subsection{Variables}

Variables are declared with the following pattern:

\texttt{TYPE ID = VALUE;}

\noindent where \texttt{TYPE} is a type definition (Section~\ref{sec:types}), \texttt{ID} a variable identifier (starting with a letter followed by alphanumeric or underscores) and \texttt{VALUE} a constant (Section~\ref{sec:csts}).

The initializer is mandatory, and is always a simple constant (no expressions), or the special
value \texttt{uninitialized}. The later indicates that the initialization can be skipped, reducing design size. This is particularly interesting on brams/broms and register arrays.

\subsection{Tables}

\texttt{intN tbl[M] = \{...\} }

\noindent Example:  \texttt{int6 tbl[4] = \{0,0,0,0\};}

Table sizes have to be constant at compile time. The initializer is mandatory and can be a string, in which case each letter becomes its ASCII value, and the string is null terminated. 

The table size \texttt{M} is optional (eg. \texttt{int4 tbl[]=\{1,2,3\};} ) in which case the size is automatically derived from the initializer (strings have one additional implicit character: the null terminator).

If the table size is specified and the initializer is a shorter string, the table is automatically padded with zeros. A longer string results in an error. 

If the table size is specified and the initializer -- not a string -- has a different number of elements, an error occurs. However, if a smaller number of elements is given the last element can be \texttt{pad(value)} in which case the remainder of the table is filled with \texttt{value}.

\noindent Example:  \texttt{int6 tbl[256] = \{0,0,0,0,pad(255)\};}

\noindent Example:  \texttt{int6 tbl[256] = \{pad(0)\};}

The keyword \texttt{uninitialized} may be used to explicitly skip table initialization, in which case the initial table state is unknown: \texttt{int6 tbl[4] = uninitialized;}. 

Similarly, the padding can be uninitialized: 
\texttt{int6 tbl[256] = \{0,0,0,0,pad(uninitialized)\};}.
In this case, only the first part of the table will be initialized, the state of the other values will be unknown.

\subsection{Block RAMs / ROMs}

\texttt{bram intN tbl[M] = \{...\} }

\noindent Block RAMs are declared in a way similar to tables. Block RAMs map to special FPGA blocks and avoid using FPGA LUTs to store data. However, accessing a block RAM typically requires a one cycle latency.

A block RAM variable has four members accessible with the 'dot' syntax: 
\begin{enumerate}
	\item {\tt addr} the address being accessed,
	\item {\tt wenable} set to 1 if writing, set to 0 if reading,
	\item {\tt rdata} result of read,
	\item {\tt wdata} data to be written.
\end{enumerate}

Here is an example of using a block RAM in \silice{}:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
bram int8 table[4] = {42,43,44,45};
int8 a = 0;

table.wenable = 0; // read
table.addr    = 2; // third entry
++:                // wait on clock
a = table.rdata;   // now a == 44
\end{minted}

Finally, an advanced option lets you indicate that the BRAM inputs need
not be latched:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
bram int8 table<input!>[4] = uninitialized;
\end{minted}

This is used to minimize a design size ; however the caller has to ensure
values are all properly present at the right cycle when reading/writing.

The rules for initializers of BRAMs are the same as for tables.

\paragraph{Block ROMs}

ROMs use a similar syntax, using \texttt{brom} instead of \texttt{bram}.

\paragraph{Dual-port RAMs}

A dual-port block RAM has eight members accessible with the 'dot' syntax: 
\begin{enumerate}
	\item {\tt addr0} the address being accessed on port 0,
	\item {\tt wenable0} write enable on port 0,
	\item {\tt rdata0} result of read on port 0,
	\item {\tt wdata0} data to be written on port 0,
	\item {\tt addr1} the address being accessed on port 1
	\item {\tt wenable1} write enable on port 1,
	\item {\tt rdata1} result of read on port 1,
	\item {\tt wdata1} data to be written on port1.
\end{enumerate}

The dual-port BRAM also has optional clock parameters for port0 and port1.

Here is an example of using a block RAM in \silice{} with different clocks:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
dualport_bram int8 table<@clock0,@clock1>[4] = {42,43,44,45};
\end{minted}

% --------------------------

\subsection{Operators}

\subsubsection{Swizzling}

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
int6 a = 0;
int1 b = a[1,1]; // second bit
int2 c = a[1,2]; // int2 with second and third bits
int3 d = a[2,3]; // int3 with third, fourth and fifth bits
\end{minted}

The first entry may be an expression, the second has to be a constant.

\subsubsection{Arithmetic, comparison, bit-wise, reduction, shift}

All standard verilog operators are supported, binary and unary.

\subsubsection{Concatenation}

Concatenation allows to combine expressions to form expressions having larger bit-width.
The syntax is to form a comma separated list enclosed by braces.  Example:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
  int6  i = 6b111000;
  int2  j = 2b10;
  int10 k = 0;
  k := {j,i,2b11};
\end{minted}

Here c is obtained by concatenating a,b and the constant 2b11 to form a ten bits wide integer.

Bits can also be replicated with a syntax similar to Verilog:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
  uint2  a = 2b10;
  uint9  c = 0;
  c := { 1b0, {8{a[1,1]}} };
\end{minted}

Here the last eight bits of variable c are set to the second bit of a.

\subsubsection{Bindings}
\label{sec:bindings}

\silice{} defines operators for bindings the input/output of algorithms and modules:
\begin{itemize}
	\item \texttt{<:} binds right to left
	\item \texttt{:>} binds left to right
	\item \texttt{<:>} binds both ways % \todo{not yet implemented}
\end{itemize}

The bound sides have to be VIO identifiers. To bind expressions you can use expression tracking~(see Section~\ref{sec:exprtrack}).

Bound VIOs are connected and immediately track each others values.
A good way to think of this is as a physical wire between IC pins, where each VIO is a pin.
Bindings are specified when instantiating algorithms and modules. 

The bidirectional binding is reserved for two use cases:
\begin{enumerate}
\item binding \texttt{inout} variables,
\item binding IO groups (see Section~\ref{sec:groups}).
\end{enumerate}

\paragraph{Advanced}

There are two specialized versions of the binding operators:
\begin{itemize}
	\item \texttt{<:} binds right to left, using value at prior clock rising edge,
	\item \texttt{<::>} binds an IO group, using value at prior clock rising edge for inputs.
\end{itemize}

Normally, the bound inputs are tracking the value of the bound VIO as they are changing during the current clock cycle. Therefore, the tracking algorithm/module immediately gets new values (in other words, there is a combinatorial connection). However, in specific cases one needs to bind the value as it was at the last (positive) clock edge, ignoring ongoing changes. This may, for instance, be necessary to avoid a combinatorial cycle.

\subsubsection{Always assign}
\label{sec:contassign}

\silice{} defines operators for continuous assignment of VIOs.
A continuous assignment is performed at each clock rising edge, regardless of the execution state of the algorithm. The left side of the assignment has to be a VIO identifier, while the right side may be an expression.
\begin{itemize}
\item \texttt{:=} assign right to left at each rising clock.
\item \texttt{::=} assign right to left with a one clock cycle delay (two stages flip-flop for e.g. clock domain crossing).
\end{itemize}

Continuous assignments are specified just after variable declarations and algorithms/modules instantiations. A typical use case is to make something pulse high, for instance:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm writer(
  output uint1 write, // pulse high to write
  output uint8 data,  // byte to write
  // ...
) {

  write := 0; // maintain low with always assign
  // ...
  if (do_write) {
    data  = ...;
    write = 1; // pulses high on next rising clock
  }
  
}
\end{minted}


\textbf{Important:} the assignment is performed immediately after the clock rising edge. If the value of the expression in the right hand side is later changing (during the clock cycle), this will not change the value of the left hand side.
To achieve this use \textit{expression tracking} (see next).

\subsubsection{Expression tracking}
\label{sec:exprtrack}

Variables can be defined to constantly track the value of an expression. This is done during the variable declaration, using either the \textit{:=} or \textit{::=} operators. Example:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm adder(
  output uint9 o,
  // ...
) {
  uint8 a = 1;
  uint8 b = 2;
  uint9 a_plus_b := a + b;
  
  a = 15;
  b = 3;
  o = a_plus_b;
}
\end{minted}

In this case \textit{o} gets assigned 15+3 on line 11, as it tracks immediate changes to the expression \textit{a+b}. Note that the variable \textit{a\_plus\_b} becomes read only (in Verilog terms, this is now a wire). We call \textit{o} an expression tracker.

The second operator, \textit{::=} tracks the expression using the values of the variables as they where at the previous clock rising edge. If used in this example, o would be assigned 1+2.

Expression trackers can refer to other trackers, however trackers using \textit{:=} and \textit{::=} cannot be mixed.

% --------------------------

\subsection{Groups}
\label{sec:groups}

Often, we want to pass around variables that form conceptual groups, like the interface to a controller. \silice{} has a specific mechanism to help with that. A group is declared as:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
// SDRAM interface
group sdio
{
  uint23 addr       = 0,
  uint2  wbyte_addr = 0,
  uint1  rw         = 0,
  uint32 data_in    = 0,
  uint32 data_out   = 0,
  uint1  busy       = 0,
  uint1  in_valid   = 0,
  uint1  out_valid  = 0
}
\end{minted}

A group variable can be declared directly:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
sdio sd; // init values are defined in the group declaration
\end{minted}

To pass a group variable to an algorithm, we need to defined an IO group. This will further specify which group members are input and outputs:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm sdramctrl(
  // ..
  // interface
  sdio sd {
    input   addr,       // address to read/write
    input   wbyte_addr, // write byte address with 32-bit word at addr
    input   rw,         // 1 = write, 0 = read
    input   data_in,    // data from a read
    output  data_out,   // data for a write
    output  busy,       // controller is busy when high
    input   in_valid,   // pulse high to initiate a read/write
    output  out_valid   // pulses high when data from read is
}    
) {
  // ..
\end{minted}

Binding to the algorithm is then a single line ; in the parent:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
sdramctrl memory(
  sd <:> sd,
  // ..
);
\end{minted}

\vspace*{5mm}
\noindent
\framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{
		\textbf{Note:} A group cannot contain tables.}}

\subsection{Bitfields}
\label{sec:bitfields}

There are many cases where we pack multiple data in a larger variable, for instance:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
  uint32 data = 32hffff1234;
  // ..
  left  = data[ 0,16];
  right = data[16,16];
\end{minted}

The hard coded values make this type of code quite hard to read and difficult to maintain. To cope with that, \silice{} defines bitfields. A bitfield is first declared:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
bitfield Node {
  uint16 right,
  uint16 left
}
\end{minted}

Note that the first entry in the list is mapped to the higher bits of the field.

This can then be used during access, to unpack the data:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
left  = Node(data).left;
right = Node(data).right;
\end{minted}

There is no overhead to the mechanism, and different bitfield can be used on a same
variable depending on the context (e.g. instruction decoding).

The bitfield can also be used to initialize the wider variable:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
uint32 data = Node(left=16hffff,right=16h1234);
\end{minted}

\subsection{Intrinsics}

\silice{} has convenient intrinsics:

\begin{itemize}
	\item \texttt{\_\_signed(exp)} indicates the expression is signed (Verilog \texttt{\$signed})
	\item \texttt{\_\_unsigned(exp)} indicates the expression is unsigned (Verilog \texttt{\$unsigned})
	\item \texttt{\_\_display(format\_string,value0,value1,...)} maps to Verilog \texttt{\$display} allowing text output during simulation.
\end{itemize}
	
% ==============================================

\section{Algorithms}

Algorithms are the main elements of a \silice{} design. An algorithm is a specification of a circuit implementation. Thus, like modules in \verilog{}, algorithms have to be instanced before being used. Each instance becomes an actual physical layout on the final design.
An algorithm can instance other algorithms and \verilog{} modules. 

Instanced algorithms \textit{always run in parallel}. However they can be called synchronously (implying a wait state in the caller). They may run forever and start automatically. Each may be driven from a specific clock and reset signal.

\paragraph{main (entry point).}
The top level algorithm is called \textit{main} and has to be defined. It is automatically instanced by the \textit{host hardware framework}, see Section~\ref{sec:host}.

% -----------------------

\subsection{Declaration}

An algorithm is declared as follows:
\begin{minted}[linenos,frame=lines,framesep=2mm]{verilog}
algorithm ID (
input TYPE ID
...
output TYPE ID
...
output! TYPE ID
...
) <MODS> {
  DECLARATIONS
  SUBROUTINES
  ALWAYS_ASSIGNMENTS
  ALWAYS_BLOCK
  INSTRUCTIONS
}
\end{minted}

Most elements are optional: the number of inputs and outputs can vary, the modifiers may be empty (in which case the \texttt{'<>'} is not necessary) and declarations, bindings and instructions may all be empty.

Here is a simple example:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm adder(intput uint8 a,intput uint8 b,output uint8 v)
{
  v = a + b;
}
\end{minted}

\noindent Let us now discuss each element of the declaration.

% -----------------------

\paragraph{Inputs and outputs.}

Inputs and outputs may be declared in any order, however the order matters when calling the algorithms (parameters are given in the order of inputs, results are read back in the order of outputs). Input and outputs can be single variables or tables.
A third type \texttt{inout} exists for compatibility with \verilog{} modules, however these can only be passed and bound to imported modules (i.e. they cannot be used in expressions and instructions for now).

Note that there are two types of output: \texttt{output} and \texttt{output!}. These distinguish between a standard and a combinational output (exclamation mark). A standard output sees its value updated at the next clock cycle. A combinational output ensures that callers sees the results within the same combinational chain. This is for instance important when implementing a video driver; e.g. a HDMI module generates a pixel coordinate on its output and expects to see the corresponding color on its input within the same clock step. Thus, the algorithm outputting the color to the HDMI driver will input the coordinate and use \texttt{output!} for the color. However, using only \texttt{output!} will in some cases result in combinational loops, leading to unstable circuits.

% ----------------------------------------------

\paragraph{Declarations.} Variables, instanced algorithms and instanced modules have to be declared first (in any order). A simple example:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main(output uint8 led)
{
  uint8 r = 0;
  adder ad1;
  
  // ... btw this is a comment
}
\end{minted}

% ----------------------------------------------

\subsection{Instantiation}
\label{sec:instantiation}

Algorithms and modules can be instanced from within a parent algorithm. Optionally parameters can be \textit{bound} to the parent algorithm variables. 
In terms of hardware, these are the wires connecting instanced and parent algorithms.
%
Instantiation uses the following syntax:
%
\begin{minted}[linenos,frame=lines,framesep=2mm]{verilog}
MOD_ALG ID<@CLOCK,!RESET> (
BINDINGS
(<:auto:>)
);
\end{minted}
%
where \texttt{MOD\_ALG} is the name of the module/algorithm, \texttt{ID} an
identifier for the instance, and \texttt{BINDINGS} a comma separated list of 
bindings between the instance inputs/outputs and the parent algorithm variables.
The bindings are optional and may be partial.
\texttt{@CLOCK} optionally specifies a clock signal, \texttt{!RESET} a reset signal, where \texttt{CLOCK} and \texttt{RESET} have to be \texttt{uint1} variables in the parent algorithm. Both are optional, and if none is specified the brackets \texttt{<>} can be skipped. When none are specified the parent \texttt{clock} and \texttt{reset} are used for the instance.

Each binding is defined as:
\texttt{ID\_left OP ID\_right} 
where \texttt{ID\_left}
is the identifier of an instance input or output, \texttt{OP} a binding
operator (Section~\ref{sec:bindings}) and \texttt{ID\_right} a variable identifier.

Note that only identifiers are allowed in bindings: access to tables and swizzling are not allowed. This can be alleviated using expression tracking, see Section~\ref{sec:exprtrack}.

Combined with \texttt{autorun} such bindings allow to instantiate and immediately run an algorithm to drive some of the parent algorithm variables. 
Here is an example:
%
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm blink(output int1 b_fast,output int1 b_slow) <autorun>
{
  uint20 counter = 0;
  while (1) {
    counter = counter + 1;
      if (counter[0,8] == 0) {
        b_fast = !b_fast;
      }
      if (counter == 0) {
        b_slow = !b_slow;
      }
  }
}

algorithm main(output int8 led)
{
  int1 a = 0;
  int1 b = 0;
  blink b0(
    b_slow :> a,
    b_fast :> b
  );

  led := 0;      // turn off all eight LEDs
  led[0,1] := a; // first LED tracks slow blink
  led[1,1] := b; // second LED tracks fast blink

  while (1) { } // inifinite loop, blink runs in parallel
}
\end{minted}
%
This example reveals some interesting possibilities, and a constraint.
As algorithm \texttt{blink} is instanced as \texttt{b0}, it starts running immediately (due to the \texttt{autorun} modifier in the declaration of \texttt{blink}). Hence, the variables \texttt{a} and \texttt{b}
are immediately tracking the \texttt{b\_slow} and \texttt{b\_fast} outputs of \texttt{b0}. The always assignment to \texttt{led} then use \texttt{a} and \texttt{b} to output to the \texttt{led} 8-bit variable, which we assume is physically connected to LEDs. The first assignment sets \texttt{led} to zero, and then its two first bits to \texttt{a} and \texttt{b}. As the always assignments are order dependent, this behaves properly with the two first bits always assigned at each clock cycle. Since all updates in \texttt{main} are done through bindings and alway assignments, and because \textit{algorithms run in parallel}, there is nothing else to do, and \texttt{main} enters an infinite loop (runs as long as there is power).

The constraint, however, is that \texttt{a} and \texttt{b} are necessary. This is due to the fact that we cannot directly bind \texttt{led[0,1]} and \texttt{led[1,1]} to the instance of \texttt{blink}. Only identifiers can be specified during bindings. This can be alleviated by using expression tracking (see Section~\ref{sec:exprtrack}).

\paragraph{Automatic binding.}
The optional \texttt{<:auto:>} tag allows to automatically bind matching identifiers:
the compiler finds all valid left/right identifier pairs having the same name and
binds them directly. While this is convenient when many bindings are repeated and passed
around, it is recommended to use groups for brevity and make all bindings explicit. 

\paragraph{Direct access to inputs and outputs.}

The inputs and outputs of instanced algorithms, when not bound,
can be directly accessed using a 'dot' notation. Outputs can be read
and inputs written to.
Example:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm algo(input uint8 i,output uint o)
{
  o = i;
}

algorithm main(output uint8 led)
{
  algo a;
  a.i = 131;
  () <- a <- (); // this is a call without explicit inputs/outputs
  led = a.o;
}
\end{minted}



% \todo{}



% ----------------------------------------------

\subsection{Call}

Algorithms may be called synchronously or asynchronously, with or without parameters. Only instanced algorithms may be called.

The asynchronous call syntax is as follows:
\begin{minted}[linenos,frame=lines,framesep=2mm,escapeinside=||,mathescape=true]{verilog}
ID <- (|$P_0,...,P_{N-1}$|); // with parameters
ID <- (); // without parameters
\end{minted}
Where \texttt{ID} is the instanced algorithm name.
When the call is made with parameters, all have to be specified. The parameters
are given in the same order they are declared in the algorithm being called.
The call without parameters is typically used when inputs are bound or specified
directly. Note that when parameters are bound, only the call without parameters
is possible.

When an asynchronous call is made, the instanced algorithm will start processing at the next clock cycle. The algorithm runs in parallel to the caller and any other instanced algorithm. To wait and obtain the result, the join syntax is used:

\begin{minted}[linenos,frame=lines,framesep=2mm,escapeinside=||,mathescape=true]{verilog}
(|$V_0,...,V_{N-1}$|) <- ID; // with receiving variables
() <- ID; // without receiving variables
\end{minted}



\vspace*{5mm}
\noindent
\framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{
\textbf{Note:} Calling algorithms across clock domains is not yet supported. For such cases, autorun with bindings is recommended.}}

% ----------------------------------------------

\subsection{Subroutines}

Algorithms can contain subroutines. These are local routines that can be called by the algorithm multiple times. A subroutine takes parameters, and has access to the variables, instanced algorithms and instanced modules of the parent algorithm -- however access permissions have to be explicitly given. 
%
Subroutines offer a simple mechanism to allow for the equivalent of local functions, without having to wire all the parent algorithm context into another module/algorithm. Subroutines can also declare local variables, visible only to their scope. Subroutines avoid duplicating a same functionality over and over, as their code is synthesized a single time in the design, regardless of the number of times they are called.

A subroutine is declared as:

\begin{minted}[linenos,frame=lines,framesep=2mm]{verilog}
subroutine ID(
input TYPE ID
...
output TYPE ID
...
reads ID
...
writes ID
...
readwrites ID
...
calls ID
) {
  DECLARATIONS
  INSTRUCTIONS
  return;
}
\end{minted}
\noindent (return is optional)

Here are simple examples:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main(output uint8 led)
{
  uint8  a       = 1;

  subroutine shift_led(readwrites a) {
    a = a << 1;
    if (a == 0) {
      a = 1;
    }
  }

  subroutine wait() {
    uint20 counter = 0;
    while (counter != 0) {
      counter = counter + 1;
    }
  }
    
  led := a;
  
  while(1) {
    () <- wait <- ();
    () <- shift_led <- ();
  }
}
\end{minted}

\noindent \textit{Subroutines permissions.} Subroutine permissions ensure only those variables given read/write
permission can be manipulated. This mitigates the fact that a subroutine may directly manipulate variables in the 
parent algorithm. The format for the permissions is a comma separated list using keywords \texttt{reads}, \texttt{writes}, \texttt{readwrites} \\

\noindent \textit{Why subroutines?} There is a fundamental difference between a subroutine and an algorithm called from 
a host: the subroutine never executes in parallel, while a child algorithm could. However, if this parallelism is not necessary, 
subroutines offer a simple mechanism to repeat internal tasks.\\~

\noindent \textit{Global subroutines} Subroutines may be declared outside of an algorithm. Such subroutines are called \textit{global} and may be called from any algorithm. This is convenient to share subroutines across algorithms. If a global subroutine requests access to parent algorithm variables (read/write permissions), an algorithm calling the subroutine has to have a matching set of variables in its scope. Note that global subroutines are not technically shared, but rather copied in each calling algorithm's scope at compile time.

\noindent \textit{Nested calls}

Subroutines can call other subroutines, and have to declare this is the case using the keyword \texttt{calls}.

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
subroutine wait(input uint24 delay)
{
  // ...
}
subroutine init_device(calls wait)
{
  // ...
  () <- wait <- (1023);
}
\end{minted}

Note that re-entrant calls (subroutine calling itself, even through other subroutines) are not possible.

% ----------------------------------------------

\subsection{Circuitry}

Sometimes, it is useful to write a generic piece of code that can
be instantiated within a design. Such an example is a piece of circuitry
to write into an SDRAM, which bit width may not ne known in advance.

A circuitry offers exactly this mechanism in \silice{}. It is declared as:

\begin{minted}[linenos,frame=lines,framesep=2mm]{verilog}
circuitry ID(
input ID
output ID
inout ID
) {
INSTRUCTIONS
}
\end{minted}

Note that there is no type specification on inputs/outputs as these are resolved during instantiation. Here is an example of circuitry:

\begin{minted}[linenos,frame=lines,framesep=2mm]{verilog}
circuitry writeData(inout sd,input addr,input data) {
  // wait for sdram to not be busy
  while (sd.busy) { /*waiting*/ }
  // write!
  sd.data_in      = rdata;
  sd.addr         = addr;
  sd.in_valid     = 1;
}
\end{minted}

Note the use of inout for sd (which is a group, see Section~\ref{sec:groups}). 
A circuitry is not called, it is instantiated. This means that
every instantiation is indeed a duplication of the circuitry.

Here is the syntax for instantiation:

\begin{minted}[linenos,frame=lines,framesep=2mm]{verilog}
(output_0,...,output_N) = ID(input_0,...input_N)
\end{minted}
As for algorithms and subroutines, inputs and outputs have to appear
in the order of declaration in the lists. An inout appears twice, both as output and input. Following the previous example here is the instantiation from an algorithm:

\begin{minted}[linenos,frame=lines,framesep=2mm]{verilog}
(sd) = writeData(sd,myaddr,abyte);
\end{minted}

\vspace*{5mm}
\noindent
\framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{
		\textbf{Note:} currently circuitry instantiation can only be made on VIO identifiers (no expressions, no bit-select or part-select. This restriction will be removed at some point.}}

% ----------------------------------------------

\subsection{Combinational loops}

When writing code, you may encounter a case where the \silice{} compiler
raises an error due to an expression leading to a combinational loop. This
indicates that the sequence of operations is leading to a cyclic dependency
in the combinational chain. These are in most
cases undesirable as they lead to unpredictable hardware behaviors.

A trivial solution is such a situation is to split the combinational chain
using the \textit{step} operator (see Section~\ref{sec:step}). However,
doing so automatically would introduce sequencing 'behind the curtain'
which we absolutely avoid in \silice{}, as this can lead to all sort of synchronization issues (see Section~\ref{sec:execflow} for more information). 
Instead, an error is reported and you are invited to either manually add
a step, or to revise the code. In many cases a slight rewrite avoids the
issue entirely.

\vspace*{2mm}
\noindent Example of a combinational loop:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main()
{
  uint8 a = 0;
  a = a + 1; // triggers a combinational loop error
}
\end{minted}

So what happens? It might seem that \texttt{a = a + 1} is the problem here, as it writes as a cyclic dependency. In fact, that is not the sole cause. On its own, this expression is perfectly fine: for each variable \silice{} tracks to versions, the one of the previous clock tick and the one of the current. So \texttt{a = a + 1} in fact means $a_{current} = a_{previous} + 1$.

The problem here comes from the initialization of $a$, in the declaration. This already set a new value to $a_{current}$, and thus the next expression \texttt{a = a + 1} would have to use this new value (otherwise it would be ignored entirely!). This now leads to $a_{current} = a_{current} + 1$ which this time is a combinational loop.

\vspace*{2mm}
\noindent The solution is simple:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main()
{
  uint8 a = 0;
  ++: // wait one cycle
  a = a + 1; // now this is fine
}
\end{minted}

It would be difficult to manually keep track of all these potential chains, which is why \silice{} does it for you! In practice, such loops are rarely encountered, and in most cases easily resolved with slight changes to arithmetic and logic.

\vspace*{5mm}
\noindent
\fbox{Note: combinational loops \textit{across} algorithms  (i.e. through \texttt{output!}) are currently not detected.}

% ----------------------------------------------

\subsection{Always assignments}

After declarations, optional always assignments can be specified.
These use the operators defined in Section~\ref{sec:contassign}.
%
Always assignments allow to track the value of an expression
in a variable, output, or instanced algorithm input or output.

\noindent Example:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main(output uint8 led)
{
  uint8 r = 0;
  adder ad1;

  led   := r;
  ad1.a := 1;
}
\end{minted}

\noindent These assignments are performed immediately after each rising clock and are order dependent. For instance:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
b := a;
c := b;
\end{minted}
is not the same as:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
c := b;
b := a;
\end{minted}
In the first case, c will immediately take the value of a, while in the second case
c will take the value of a after one clock cycle. This is useful, for instance, when
crossing a clock domain as it allows to implement a two stages flip-flop. In fact,
\silice{} provides a shortcut for exactly this purpose, making the temporary variable b unnecessary:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
c ::= a;
\end{minted}

% ----------------------------------------------

\subsection{Always block}

An algorithm can have an always block. This block has to be combinational (no goto, while or step operator inside). It is always running, regardless of the state of the rest of the algorithm, and is executed immediately after always assignments, and before anything else.

The syntax simply is:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
always {
  // instructions
  // ...
}
\end{minted}

Assigning a variable in an always block or using an always assignment is in fact equivalent, that is:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
always {
  a = 0;
}
\end{minted}

\noindent is functionally the same as

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
a := 0;
\end{minted}

% ----------------------------------------------

\subsection{Clock and reset}

All algorithms receive a \texttt{clock} and \texttt{reset} signal from their
parent algorithm. These are intrinsic variables, are always defined within
the scope of an algorithm and have type \texttt{int1}. The clock and reset
can be explicitly specified when an algorithm is instanced (Section~\ref{sec:instantiation}).

% ----------------------------------------------

\subsection{Modifiers}

Upon declaration, modifiers can be specified (see \texttt{<MODS>}) in the declaration). This is a comma separated list of any of the following:

\begin{itemize}
	\item \textbf{Autorun.} Adding the \texttt{autorun} keyword will ask the compiler to run the algorithm upon instantiation, without waiting for an explicit call.
	\item \textbf{Internal clock.} Adding a \texttt{@ID} specifies the use of an internally generated clock signal. It is then expected that the algorithm contains a \texttt{int1 ID = 0;} variable declaration, which is bound to the output of a module producing a clock signal. This is meant to be used together with \verilog{} PLLs, to produce new clock signals. The module producing the new clock will typically take \texttt{clock} as input and \texttt{ID}
	as output.
	\item \textbf{Internal reset.} Adding a \texttt{!ID} specifies the use of an internally generated reset signal. It is then expected that the algorithm contains a \texttt{int1 ID = 0;} variable declaration, which is bound to the output of a module producing a reset signal. This may be used, for instance, to filter the signal from a physical reset button.
	\item \textbf{Stack.} Adding the \texttt{stack:N} modifier (with N an integer > 1) will allocate a stack of size N for the algorithm subroutine nested calls.
	\item \textbf{One-hot.} Adding the \texttt{onehot} modifier will use a 'onehot' state numbering for the algorithm state machine. On small algorithms with few states this can result in smaller, faster designs.
\end{itemize}

Here is an example:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
  algorithm main(output int1 b) <autorun,@new_clock>
  {
    int1 new_clock = 0;

    my_pll pll(
      base_clock <: clock,
      gen_clock :> new_clock
    );

    // the main algorithm is sequenced by new_clock
    // ...
  }
\end{minted}

Which signals are allowed as clocks and resets depends on the FPGA architecture
and vendor toolchain.


% ----------------------------------------------

\section{Execution flow and cycle utilization rules}
\label{sec:execflow}

Upon compilation, \silice{} breaks down the code into a finite state machine (FSM) and corresponding combinational chains.
%
\silice{} attempts to form the longest combinational chains, or equivalently
to minimize the number of states in the FSM. That is because going from one state to the next requires one clock cycle, delaying further computations.
%
Of course, longer combinational chains also lead to reduced clock frequency, so
there is a tradeoff. This is why \silice{} lets you explicitly specify where to cut a combinational chain using the step operator \texttt{++:}

Note that if a state contains several independent combinational chain, they will execute as parallel circuits (e.g. two computations regarding different sets of variables). Grouping such computations in a same state increases parallelism, without deepening the combinational chains.

The use of control flow structures such as \texttt{while} (or \texttt{goto}), as well as synchronization with other algorithm also require introducing states. This results in additional cycles being introduced. \silice{} follows a set of precise rules to do this, so you always know what to expect.

\subsection{The {step} operator}
\label{sec:step}

Placing a \texttt{++:} in the sequence of operations of an algorithm explicitly asks \silice{} to wait for exactly one cycle at this precise location in the execution flow. Each next \texttt{++:} waits one additional cycle.

This has several important applications such as waiting for a memory read/write, or breaking down long combinational chains that would violate timing.

% ----------------------------------------------

\subsection{Control flow}

The core control flow operations are \texttt{goto}, \texttt{call} and \texttt{return} (\texttt{call} is a \texttt{goto} preparing a return address for \texttt{return}). 
%
While \texttt{goto} and \texttt{call} may be used directly, it is recommended to prefer higher level primitives such as \texttt{while} and subroutines, because \texttt{goto} often leads to harder to read and maintain code\footnote{See the famous Dijkstra's paper about this~\cite{dijkstra}}. 
Yet, they are a fundamental low-level operation and \silice{} is happy to expose them for your enjoyment!

\texttt{goto} and \texttt{call} always require one cycle to 'jump': this is a change of state in the FSM. Entering a \texttt{while} takes one cycle and then, if there is a single combinational chain inside, it takes exactly one cycle per iteration. 

Now, \texttt{if-then-else} is slightly more subtle. When applied to sequences of operations not requiring any control flow, an \texttt{if-then-else} synthesizes to a combinational \texttt{if-then-else}. This means that both the 'if' and 'else' code are evaluated in parallel as combinational chains, and a multiplexer selects which one is the result based on the condition. This applies recursively, so combinational \texttt{if-then-else} may be nested.

When the \texttt{if-then-else} contains additional control flow (e.g. a subroutine call, a \texttt{while}, a \texttt{++:}, a \texttt{goto}, etc.) it is automatically split into several states. It then takes one cycle to exit the 'if' or 'else' part and resume operations.
If only the 'if' or the 'else' requires additional states while the other is a single combinational chain (possibly empty), an additional state is still required to 'jump' to what comes after the \texttt{if-then-else}. So in general this will cost one cycle. However, in cases where this next state already exists, for instance when the \texttt{if-then-else} is at the end of a \texttt{while} loop, this existing state is reused resulting in no overhead.

This has interesting implications. Consider the following code:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
while(...) {
  if (condition) {
    ...
++:
    ...    
  }
  a = b + 1;
}
\end{minted}

When the \texttt{if} is not taken, we still have to pay one cycle to reach line 7. That is because it has been place into a separate state since the \texttt{if} contains non-combinational code that has to jump to reach it. Hence, the while loop will always take at least two cycles.

However, you may choose to duplicate some code (and hence some circuitry!) to avoid the extra cycle, rewriting as:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
while(...) {
  if (condition) {
    ...
++:
    ...    
    a = b + 1;
  } else {
    a = b + 1;
  }
}
\end{minted}

This works because when the \texttt{if} is taken the execution simply goes back to the start of the \texttt{while}, a state that already exists. The \texttt{else} being combinational and also followed by the start of the \texttt{while} no extra cycle is necessary! We just tradeoff a bit of circuit size for extra performance.

% ----------------------------------------------

\subsection{Cycle costs of calls to algorithms and subroutines}

A synchronized call to an algorithm takes at best two cycles: one cycle for the algorithm to start processing, and one cycle to register that the algorithm is done. An asynchronous call is a combinational operation (and the algorithm will start running on the next clock cycle), while a synchronization inserts a state in the control flow and always requires at least one cycle, even if the algorithm is already finished.

A synchronized call to a subroutine takes at best two cycles: one cycle to jump to the subroutine initial state, and one cycle to jump back.

\vspace*{5mm}
\noindent
\framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{
		\textbf{Note:} Keep in mind that algorithms can also autorun and have their inputs/outputs bound to variables (see Section \ref{sec:instantiation}). Algorithms may also contain a combinational \texttt{always} block that is always running.}}

% ----------------------------------------------

\subsection{Pipelining} 

\todo{describe syntax \ttfamily{\{ \} -> \{ \}}}

% ----------------------------------------------

\section{Lua preprocessor}

A preprocessor allows to change the way the source code is seen by the compiler.
It sits between the input source code and the compiler, and basically rewrites the
original source code in a different way, before it is input to the compiler.
This allows compile-time behaviors, such as adapting the code to a target platform.

Having a strong preprocessor is important for hardware design. For instance,
designing a sort network of some size $N$ is best done by generating the code 
automatically from a preprocessor, so that one can easily reuse the
same code for different values of $N$. The same is true of a division 
algorithm for some bit width, or for the pre-computations of lookup tables.

The \silice{} preprocessor is built above the Lua language~\url{https://lua.org}. Lua is an amazing powerful, lightweight scripting language that originated in the Computer Graphics community. The preprocessor is thus not just a macro system, but a fully fledged programming language.

\subsection{Principle and syntax}

Preprocessor code is directly interleaved with Silice code. At any point, the source code can be escaped to the preprocessor by starting a line with \$\$. The full line is then considered as preprocessor Lua code. 

The pre-processor sees Silice source lines as strings to be output. 
Thus, it outputs to the compiler any line that is met during the execution
of the preprocessor. This means it does not output those that are not reached, and
it outputs multiple times those that appear in a loop.

Let's make a quick example:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main()
{

$$if true then
  uint8 a=0;
  uint8 b=0;
$$end

$$if false then
uint8 c=0;
$$end

$$for i=0,1 do
b = a + 1;
$$end
}
\end{minted}

The code output by the preprocessor is:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main()
{

uint8 a=0;
uint8 b=0;

b = a + 1;
b = a + 1;

}
\end{minted}

Note that source code lines are either fully \silice{}, of fully preprocessor (starting with \$\$). A second syntax allows to use preprocessor variables directly in \silice{} source code, simply doing \$\texttt{varname}\$ with \texttt{varname} the variable from the preprocessor context. In fact, a full Lua expression can be used in between the \$ signs; this expression is simply concatenated to the surrounding \silice{} code.

Here is an example:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main()
{
$$for i=0,3 do
uint8 a_$i$ = $100+i$;
$$end
}
\end{minted}

The code output by the preprocessor is:

\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
algorithm main()
{
uint8 a_0 = 100;
uint8 a_1 = 101;
uint8 a_2 = 102;
uint8 a_3 = 103;
}
\end{minted}

If a large chunk of Lua code has to be written, you can simply write it in a separate \texttt{.lua} file and use:
\begin{minted}[linenos,frame=lines,framesep=2mm]{c}
$$dofile('some_lua_code.lua')
\end{minted}

% ----------------------------------------------

\subsection{Includes}

The preprocessor is also in charge of including other Silice source code files,
using the syntax \texttt{\$include('source.ice')}. This loads the entire file
(and recursively its own included files) into the preprocessor execution context.

% ----------------------------------------------

\subsection{Pre-processor image and palette functions}

The pre-processor has a number of function to facilitate the inclusion of images
and palette data ; please refer to the example projects \texttt{vga\_demo}, \texttt{vga\_wolfpga} and \texttt{vga\_doomchip}.

% ----------------------------------------------

\section{Interoperability with \verilog{} modules}

\silice{} can inter-operate with \verilog{}.

\verilog{} source code can be included in two different ways: \texttt{append('code.v')} and \texttt{import('code.v')} where \texttt{code.v} is a \verilog{} source code file.

\subsection{Append}

Append is very simple: the \verilog{} source code is directly appended to the output of the compiler (which is a \verilog{} source code) without any processing. This makes this \verilog{} code available for other \verilog{} modules, in particular those that are imported (see next). The reason for \texttt{append} is that \silice{} is currently not able to fully parse \verilog{} when importing. 

\subsection{Import}

Import is the most interesting way to inter-operate with \verilog{}.
Once imported, all \verilog{} modules from the \verilog{} source file 
will be available for inclusion in algorithms.

The modules are instantiated in a very similar way as algorithms, with bindings to variables. However, modules cannot be called like algorithms, and the 'dot' syntax to read/write outputs and inputs is not available for modules.

\subsection{Wrapping}

Due to the fact that \silice{} only understands a subset of \verilog{}, there
are cases where a module cannot be imported directly. In such cases, wrapping
offers a solution. The idea is to write a simpler \verilog{} module that can be imported by \silice{} and wraps the instantiation of the more complex one.

Then the complex module is included with \texttt{append} and the wrapper with \texttt{import}.

% ==============================================

\section{Host hardware frameworks}
\label{sec:host}

The host hardware framework typically consists in a \verilog{} glue file. The framework is appended to the compiled \silice{} design (in \verilog{}). The framework instantiates the \textit{main} algorithm. The resulting file can then be processed by the vendor or open source FPGA toolchain (often accompanied by a hardware constraint file).

\silice{} comes with the following host hardware frameworks:
\begin{itemize}
	\item \textbf{mojo\_basic} : framework to compile for the Alchitry Mojo 3 FPGA board.
	\item \textbf{mojo\_hdmi\_sdram} : framework to compile for the Alchitry Mojo 3 FPGA board equipped with the HDMI shield.
	\item \textbf{icestick} : framework for the Lattice ice40 icestick board.
	\item \textbf{verilator\_bare} : framework for use with the \textit{verilator} hardware simulator
	\item \textbf{verilator\_sdram\_vga} : framework for use with the \textit{verilator} hardware simulator, with VGA and SDRAM emulation
	\item \textbf{icarus\_bare} : framework for use with the \textit{icarus}
	\item \textbf{icarus\_vga} : framework for use with the \textit{icarus} hardware simulator, with vga emulation
%	\item \todo{update with icarus, as well as bare versions, mention sdram emulator}
\end{itemize}

For practical usage examples please refer to the \textit{Getting started} guide at \url{https://github.com/sylefeb/Silice/blob/master/GetStarted.md}.

\subsection{VGA emulation}

Silice comes with a tool called \texttt{silicehe} for \textit{\silice{} hardware emulation}. This tool will read the output of the \texttt{icarus\_vga} simulator (the fst file storing signals) and produce a sequence of images from the stored VGA signals.

Simply call it with the fst file as the second argument.

% ==============================================
	
\end{document}
